{"tags":[{"name":"设计模式","permalink":"http://yoursite.com/tags/设计模式/","url":"\\async\\tags\\设计模式.json","count":3}],"categories":[],"url":"\\async\\posts\\2017\\06\\07\\Java设计模式-常用面向对象七大原则.json","date":1496838141000,"path":{"year":2017,"month":6,"day":7,"name":"Java设计模式-常用面向对象七大原则"},"title":"Java设计模式-常用面向对象七大原则","permalink":"http://yoursite.com/2017/06/07/Java设计模式-常用面向对象七大原则/","content":"<h3 id=\"一、单一职责原则-Single-Responsibility-Principle-SRP\"><a href=\"#一、单一职责原则-Single-Responsibility-Principle-SRP\" class=\"headerlink\" title=\"一、单一职责原则(Single Responsibility Principle,SRP)\"></a>一、单一职责原则(Single Responsibility Principle,SRP)</h3><p>重要系数：★★★★☆</p>\n<blockquote>\n<p>“There should never be more than one reason for a class to change”</p>\n</blockquote>\n<p>定义：类的职责要单一，不能将太多的职责放在一个类中。</p>\n<p>描述：即一个类只负责一项职责。（高内聚、低耦合）</p>\n<p>作用：为了避免（解决）由于一个负责多个职责的类，因其中一个职责的改变而影响导致其他职责产生故障的问题。</p>\n<p>优点： </p>\n<ol>\n<li>降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；</li>\n<li>提高类的可读性和系统的可维护性； </li>\n<li>变更引起的风险降低。变更是必然的，当修改一个功能时，如果单一职责原则遵守的好，可显著降低对其他功能的影响。 </li>\n</ol>\n<p>注意：</p>\n<ol>\n<li>单一职责原则不只是面向对象编程思想所特有的。只要是模块化的程序设计，都适用单一职责原则。</li>\n<li>要学会避免因需求变更或其他原因而出现职责扩散的现象。在职责扩散到我们无法控制的程度之前，要立刻对代码进行重构。</li>\n</ol>\n<p>使用单一职责原则的设计模式：</p>\n<ol>\n<li></li>\n</ol>\n<h3 id=\"二、开闭原则-Open-Closed-Principle-OCP\"><a href=\"#二、开闭原则-Open-Closed-Principle-OCP\" class=\"headerlink\" title=\"二、开闭原则(Open Closed Principle,OCP)\"></a>二、开闭原则(Open Closed Principle,OCP)</h3><p>重要系数：★★★★★</p>\n<blockquote>\n<p>“Softeware entities like classes,modules and functions should be open for extension but closed for modifications.”</p>\n</blockquote>\n<p>定义：一个软件实体如类、模块和函数对扩展开放，但对修改关闭。</p>\n<p>描述：即当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化（在不修改一个软件实体的基础上去扩展其功能）。</p>\n<p>作用：为软件实体的未来事物而制定的对现行开发设计进行约束。</p>\n<p>优点： </p>\n<ol>\n<li>通过扩展已有的软件系统，可以提供新的行为，以满足对软件新的需求，使变化中的软件系统有一定的适应性和灵活性；</li>\n<li>已有的软件模块，特别是最重要的抽象层模块不能再修改，这就使变化中的软件系统有一定的稳定性和延续性； </li>\n<li>满足了可复用性与可维护性。 </li>\n</ol>\n<p>注意：</p>\n<ol>\n<li>面向对象设计中最基础的设计原则</li>\n<li>开闭原则对扩展开放，对修改关闭，并不意味着不做任何修改，低层模块的变更，必然要有高层模块进行耦合，否则就是一个孤立无意义的代码片段了。</li>\n<li>实现开闭原则关键在于抽象化</li>\n<li>对变化的封装包含两层含义：<br>第一，将相同的变化封装到一个接口或者抽象类中；<br>第二，将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中。</li>\n</ol>\n<p>使用开闭原则的设计例子：</p>\n<ol>\n<li></li>\n</ol>\n<h3 id=\"三、里氏代换原则-Liskov-Substitution-Principle-LSP\"><a href=\"#三、里氏代换原则-Liskov-Substitution-Principle-LSP\" class=\"headerlink\" title=\"三、里氏代换原则(Liskov Substitution Principle,LSP)\"></a>三、里氏代换原则(Liskov Substitution Principle,LSP)</h3><p>重要系数：★★★★☆</p>\n<p>严格定义：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。</p>\n<p>通俗定义：在软件系统中，一个可接受基类对象的地方必然可以接受一个子类对象。</p>\n<p>描述：在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常。反过来则不成立：如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。</p>\n<p>注意：</p>\n<ol>\n<li>里氏代换原则是实现开闭原则的重要方式之一，也是开闭原则的扩充。</li>\n<li>由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</li>\n<li>当使用继承时，要遵循里氏替换原则。即子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：<br>1)子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。<br>2)子类中可以增加自己特有的方法。<br>3)当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。<br>4)当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li>\n</ol>\n<p>使用里氏代换原则的例子：</p>\n<ol>\n<li></li>\n</ol>\n<h3 id=\"四、依赖倒置原则-Dependence-Inversion-Principle，DIP\"><a href=\"#四、依赖倒置原则-Dependence-Inversion-Principle，DIP\" class=\"headerlink\" title=\"四、依赖倒置原则(Dependence Inversion Principle，DIP)\"></a>四、依赖倒置原则(Dependence Inversion Principle，DIP)</h3><p>重要系数：★★★★★</p>\n<p>定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</p>\n<p>描述：要针对抽象层编程。而不要针对具体类编程。</p>\n<p>作用：遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。</p>\n<p>注意：</p>\n<ol>\n<li>依赖倒置原则的核心思想是<code>面向接口编程</code>。</li>\n<li>修改类的依赖关系时，为避免因修改依赖类而给程序带来不必要的风险，将依赖类A修改为使用依赖接口I，被依赖类B和被依赖类C各自实现接口I：<br>即<code>类A</code>通过<code>接口I</code>间接与<code>类B</code>/<code>类C发生联系（A</code>实例化<code>I，B和C</code>implements<code>I并</code>实现`其中方法）。</li>\n<li>其实传递依赖关系有三种方式：除了前面说的<code>接口传递</code>，另外还有<code>构造方法传递</code>和<code>setter方法传递</code></li>\n<li>根据依赖倒置原则，在实际编程中一般需做到以下3点：<br>1）低层模块尽量都要有抽象类或接口，或两者都有。<br>2）变量的声明类型尽量是抽象类或接口。<br>3）使用继承时遵循里氏替换原则。 </li>\n</ol>\n<p>使用依赖倒置原则的例子：</p>\n<ol>\n<li>TDD开发模式</li>\n</ol>\n<h3 id=\"五、接口隔离原则-Interface-Segregation-Principle-ISP\"><a href=\"#五、接口隔离原则-Interface-Segregation-Principle-ISP\" class=\"headerlink\" title=\"五、接口隔离原则(Interface Segregation Principle, ISP)\"></a>五、接口隔离原则(Interface Segregation Principle, ISP)</h3><p>重要系数：★★☆☆☆</p>\n<p>定义：使用多个专门的接口来取代一个统一且臃肿的接口，即客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</p>\n<p>描述：为各个类建立专用的接口，而不要试图去建立一个过于庞大臃肿的接口供所有依赖它的类去调用。即当一个接口太大时，需要将它分割成一些更细小的接口。使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色。</p>\n<p>优点：接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p>\n<p>注意：</p>\n<ol>\n<li>在使用接口隔离原则时，需要注意控制接口的粒度：<br>1）接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；<br>2）接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。 </li>\n<li>一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。</li>\n</ol>\n<p>使用接口隔离原则的例子：</p>\n<ol>\n<li></li>\n</ol>\n<h3 id=\"六、合成复用原则-Composition-Aggregate-Reuse-Principle-CARP\"><a href=\"#六、合成复用原则-Composition-Aggregate-Reuse-Principle-CARP\" class=\"headerlink\" title=\"六、合成复用原则(Composition/Aggregate Reuse Principle, CARP)\"></a>六、合成复用原则(Composition/Aggregate Reuse Principle, CARP)</h3><p>重要系数：★★★★☆</p>\n<p>定义：复用时要尽量使用关联关系（包括组合关系和聚合关系），少用继承。</p>\n<p>描述：新的对象应尽量多使用对象间的关联关系，尽量少使用甚至不使用继承关系来达到复用已有对象的目的。</p>\n<p>优点：可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。</p>\n<p>注意：</p>\n<ol>\n<li>尽量少用继承来进行复用的主要原因在于继承复用会破坏系统的封装性，滥用继承也可能会增加系统构建和维护的难度以及系统的复杂度。 </li>\n<li>因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，这种复用称为<code>“白箱”复用</code>。<br>对于这种复用，如果基类发生改变，那么子类的实现也不得不发生改变。</li>\n<li>由于组合或聚合关系可以将已有的对象（即成员对象）纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见，这种复用称为<code>“黑箱”复用</code>。<br>对于这种复用，成员对象的变化对新对象的影响不大。</li>\n<li>一般而言，<br>如果两个类之间是<code>Has-A</code>的关系（某一个角色具有某一项责任），应使用组合或聚合;<br>如果两个类之间是<code>Is-A</code>的关系(一个类是另一个类的”一种”)，可使用继承。</li>\n</ol>\n<p>使用合成复用原则的例子：</p>\n<ol>\n<li></li>\n</ol>\n<h3 id=\"七、迪米特原则（Law-of-Demeter-LoD）-最少知识原则-LeastKnowledge-Principle-LKP\"><a href=\"#七、迪米特原则（Law-of-Demeter-LoD）-最少知识原则-LeastKnowledge-Principle-LKP\" class=\"headerlink\" title=\"七、迪米特原则（Law of  Demeter, LoD）/最少知识原则(LeastKnowledge Principle, LKP)\"></a>七、迪米特原则（Law of  Demeter, LoD）/最少知识原则(LeastKnowledge Principle, LKP)</h3><p>重要系数：★★★☆☆</p>\n<blockquote>\n<p>不要和“陌生人”说话、只与你的直接朋友通信</p>\n</blockquote>\n<p>定义：一个软件实体应尽可能少地与其他实体发生相互作用。</p>\n<p>描述：如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，而是通过引入一个第三者发生间接交互。</p>\n<p>优点：因类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。所以遵循迪米特原则可以尽量降低类与类之间的耦合，使类与类之间保持松散的耦合关系。。</p>\n<p>注意：</p>\n<ol>\n<li>每个对象都会与其他对象有耦合关系（耦合的方式很多，依赖、关联、组合、聚合等）。<br>只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。<br>我们称<code>出现在成员变量、方法参数、方法返回值中的类</code>为<code>直接的朋友</code>，而<code>出现在局部变量中的类</code>则不是直接的朋友。<br>所以，陌生的类最好不要作为局部变量的形式出现在类的内部。</li>\n<li>使用迪米特原则，通常需要利用“中介者”。但过分的使用会产生大量的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。</li>\n</ol>\n<p>使用迪米特原则的例子：<br>1. </p>\n"}
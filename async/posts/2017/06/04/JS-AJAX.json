{"tags":[{"name":"JS","permalink":"http://yoursite.com/tags/JS/","url":"\\async\\tags\\JS.json","count":14}],"categories":[],"url":"\\async\\posts\\2017\\06\\04\\JS-AJAX.json","date":1496563612000,"path":{"year":2017,"month":6,"day":4,"name":"JS-AJAX"},"title":"JS-AJAX","permalink":"http://yoursite.com/2017/06/04/JS-AJAX/","content":"<h3 id=\"AJAX\"><a href=\"#AJAX\" class=\"headerlink\" title=\"AJAX\"></a>AJAX</h3><ul>\n<li>全称：Asynchronous JavaScript and XML，即用JavaScript执行<code>异步网络请求</code>。</li>\n<li>Web的运作原理为一次HTTP请求对应一个页面。如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面。这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。即在首次加载后，剩下的所有数据都依赖于AJAX来更新。 </li>\n<li>AJAX请求是异步执行的，也就是说，要通过回调函数获得响应。</li>\n<li>在现代浏览器上写AJAX主要依靠<code>XMLHttpRequest</code>对象(对于低版本的IE，需要换一个ActiveXObject对象)。</li>\n<li><code>XMLHttpRequest</code>对象的<code>open()</code>方法有3个参数:<br>第一个参数指定是<code>GET</code>(不需参数)还是<code>POST</code>(需要把body部分以字符串或FormData对象传进去)；<br>第二个参数指定URL地址；<br>第三个参数指定是否使用异步，默认是true，所以一般省略不写（千万不要指定为<code>false</code>，否则浏览器将停止响应，直到AJAX请求完成。如果这个请求耗时10秒，那么10秒内你会发现浏览器处于“假死”状态）。</li>\n<li><p>实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">function success(text) </div><div class=\"line\">&#123;</div><div class=\"line\">    var textarea = document.getElementById(&apos;test-response-text&apos;);</div><div class=\"line\">    textarea.value = text;</div><div class=\"line\">&#125;</div><div class=\"line\">function fail(code) </div><div class=\"line\">&#123;</div><div class=\"line\">    var textarea = document.getElementById(&apos;test-response-text&apos;);</div><div class=\"line\">    textarea.value = &apos;Error code: &apos; + code;</div><div class=\"line\">&#125;</div><div class=\"line\">var request;</div><div class=\"line\">if (window.XMLHttpRequest) //注意不要根据浏览器的`navigator.userAgent`来检测浏览器是否支持某个JavaScript特性</div><div class=\"line\">&#123;</div><div class=\"line\">  request = new XMLHttpRequest();// 新建XMLHttpRequest对象(现代浏览器)</div><div class=\"line\">&#125; </div><div class=\"line\">else </div><div class=\"line\">&#123;</div><div class=\"line\">  request = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;); // 新建ActiveXObject对象(低版本的IE)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//设置onreadystatechange的回调函数(状态发生变化时，函数被回调)</div><div class=\"line\">request.onreadystatechange = function ()&#123;</div><div class=\"line\">  if (request.readyState === 4) // 成功完成</div><div class=\"line\">  &#123; </div><div class=\"line\">      if (request.status === 200) // 判断响应结果</div><div class=\"line\">      &#123;</div><div class=\"line\">          return success(request.responseText); // 成功，通过responseText拿到响应的文本(为服务端输出的内容)</div><div class=\"line\">      &#125;</div><div class=\"line\">      else </div><div class=\"line\">      &#123;</div><div class=\"line\">          return fail(request.status);// 失败，根据响应码判断失败原因:</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  else &#123;</div><div class=\"line\">     // HTTP请求还在继续...</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">request.open(&apos;GET&apos;, &apos;/api/categories&apos;); //指定GET方式， URL使用的是相对路径</div><div class=\"line\">request.send(); // 发送请求</div><div class=\"line\">alert(&apos;请求已发送，请等待响应...&apos;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>上面代码的URL使用的是相对路径。如果改为<code>&#39;http://www.sina.com.cn/&#39;</code>再运行肯定报错。在Chrome的控制台里，还可以看到错误信息。这是因为浏览器的同源策略导致的。</p>\n</li>\n<li>默认情况下，JavaScript在发送AJAX请求时，URL的域名必须和当前页面(域名、协议、端口号)完全一致。</li>\n<li>当用JavaScript请求外域（其他网站）的URL时的方法：<ol>\n<li>通过Flash插件发送HTTP请求，这种方式可以绕过浏览器的安全限制，但必须安装Flash，并且跟Flash交互，而且Flash用起来麻烦；</li>\n<li>通过在同源域名下架设一个代理服务器来转发，JavaScript负责把请求发送到代理服务器：<code>&#39;/proxy?url=http://www.sina.com.cn&#39;</code>，代理服务器再把结果返回，这样就遵守了浏览器的同源策略。这种方式麻烦之处在于需要服务器端额外做开发；</li>\n<li>这种方式称为<code>JSONP</code>，它有个限制，只能用GET请求，并且要求返回JavaScript。这种方式跨域实际上是利用了浏览器允许跨域引用JavaScript资源。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"CORS\"><a href=\"#CORS\" class=\"headerlink\" title=\"CORS\"></a>CORS</h3><ol>\n<li>全称Cross-Origin Resource Sharing，是HTML5规范定义的跨域策略。</li>\n<li><code>Origin</code>表示本域，即浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查<code>Access-Control-Allow-Origin</code>是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。</li>\n<li>实例：假设本域是<code>my.com</code>，外域是<code>sina.com</code>，只要响应头<code>Access-Control-Allow-Origin</code>为<code>http://my.com</code>或<code>*</code>，本次请求就可以成功。如下图所示：<br><img src=\"http://www.liaoxuefeng.com/files/attachments/00143640805071744d58164a40e42ef92b9973824451595000/l\" alt=\"CORS图示\"></li>\n<li>可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的<code>Access-Control-Allow-Origin</code>，决定权始终在对方手中。</li>\n<li>这种跨域请求，称之为“简单请求”。简单请求包括<code>GET</code>、<code>HEAD</code>和<code>POST</code>（POST的Content-Type类型仅限<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>和<code>text/plain</code>），并且不能出现任何自定义头（如<code>X-Custom: 12345</code>），通常能满足90%的需求。</li>\n<li>在引用外域资源时，除了JavaScript和CSS外，都要验证<code>CORS</code>。</li>\n</ol>\n<h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><ul>\n<li>JavaScript所有代码都是单线程执行的，由于这个“缺陷”，JavaScript的所有网络操作、浏览器事件，都必须是异步执行。</li>\n<li>异步执行可以用回调函数实现：一般是在将来的某个时间点触发一个函数调用。</li>\n<li>AJAX就是典型的异步操作，但上述的AJAX代码把回调函数<code>success(request.responseText)</code>和<code>fail(request.status)</code>写到一个AJAX操作里不但不美观也不利于代码复用。</li>\n<li>于是在ES6中统一规范一个由浏览器直接支持的Promise对象，用于在将来某个时候调用相应函数。</li>\n<li>使用Promise对象可使代码先统一执行AJAX逻辑，不关心(函数)如何处理结果，然后根据结果是成功还是失败，在将来的某个时候调用<code>success</code>函数/<code>fail</code>函数。</li>\n<li><p>实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">&apos;use strict&apos;;</div><div class=\"line\">// 先清除log:</div><div class=\"line\">var logging = document.getElementById(&apos;test-promise-log&apos;);</div><div class=\"line\">while (logging.children.length &gt; 1) </div><div class=\"line\">&#123;</div><div class=\"line\">    logging.removeChild(logging.children[logging.children.length - 1]);</div><div class=\"line\">&#125;</div><div class=\"line\">// 再输出log到页面:</div><div class=\"line\">function log(s) </div><div class=\"line\">&#123;</div><div class=\"line\">  var p = document.createElement(&apos;p&apos;);</div><div class=\"line\">  p.innerHTML = s;</div><div class=\"line\">  logging.appendChild(p);</div><div class=\"line\">&#125;</div><div class=\"line\">//定义Promise对象</div><div class=\"line\">//function函数在内部异步执行，只关心自身的逻辑，并不关心resolve和reject函数具体如何处理结果</div><div class=\"line\">new Promise(function (resolve, reject) //两个参数都是函数，成功或失败时分别调用</div><div class=\"line\">&#123;</div><div class=\"line\">  log(&apos;start new Promise...&apos;);</div><div class=\"line\">  var timeOut = Math.random() * 2; //生成一个0-2之间的随机数</div><div class=\"line\">  log(&apos;set timeout to: &apos; + timeOut + &apos; seconds.&apos;);</div><div class=\"line\">  setTimeout(function () &#123;</div><div class=\"line\">      if (timeOut &lt; 1) &#123;  //如小于1则等待一段时间后调用resolve函数并返回成功</div><div class=\"line\">          log(&apos;call resolve()...&apos;);</div><div class=\"line\">          resolve(&apos;200 OK&apos;);</div><div class=\"line\">      &#125;</div><div class=\"line\">      else &#123;  //失败则调用reject函数</div><div class=\"line\">          log(&apos;call reject()...&apos;);</div><div class=\"line\">          reject(&apos;timeout in &apos; + timeOut + &apos; seconds.&apos;);</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;, timeOut * 1000);</div><div class=\"line\">&#125;).then(function (r) &#123;  //如执行成功</div><div class=\"line\">  log(&apos;Done: &apos; + r);  //获得响应内容</div><div class=\"line\">&#125;).catch(function (reason) &#123;  //如执行失败</div><div class=\"line\">  log(&apos;Failed: &apos; + reason); //获得响应代码</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>可见Promise最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离。<br><img src=\"http://www.liaoxuefeng.com/files/attachments/001436512391628944d5da9a5654a35b0ace38246f30b9c000/l\" alt=\"*\"></p>\n</li>\n<li><p>setTimeout函数可看成一个模拟网络等异步执行的函数。下面把上述AJAX异步执行函数转换为Promise对象来简化异步处理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">&apos;use strict&apos;;</div><div class=\"line\">function ajax(method, url, data) // ajax函数将返回Promise对象</div><div class=\"line\">&#123;</div><div class=\"line\">  var request = new XMLHttpRequest();</div><div class=\"line\">  return new Promise(function (resolve, reject) </div><div class=\"line\">  &#123;</div><div class=\"line\">      request.onreadystatechange = function () &#123;</div><div class=\"line\">          if (request.readyState === 4) </div><div class=\"line\">          &#123;</div><div class=\"line\">              if (request.status === 200) &#123;</div><div class=\"line\">                  resolve(request.responseText);</div><div class=\"line\">              &#125; </div><div class=\"line\">              else &#123;</div><div class=\"line\">                  reject(request.status);</div><div class=\"line\">              &#125;</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;;</div><div class=\"line\">      request.open(method, url);</div><div class=\"line\">      request.send(data);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var log = document.getElementById(&apos;test-promise-ajax-result&apos;);</div><div class=\"line\">var p = ajax(&apos;GET&apos;, &apos;/api/categories&apos;);</div><div class=\"line\">p.then(function (text) &#123; // 如果AJAX成功，获得响应内容</div><div class=\"line\">  log.innerText = text;</div><div class=\"line\">&#125;).catch(function (status) &#123; // 如果AJAX失败，获得响应代码</div><div class=\"line\">  log.innerText = &apos;ERROR: &apos; + status;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>Promise还可以做更多的事情。比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。要串行执行这样的异步任务，不用Promise则需要写一层一层的嵌套代码。有了Promise，我们只需要简单地写：<br><code>job1.then(job2).then(job3).catch(handleError);</code> //其中，job1、job2和job3都是Promise对象</p>\n</li>\n<li><p>实例：串行执行一系列需要异步计算获得结果的任务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">function multiply(input)   // 0.5秒后返回input*input的计算结果</div><div class=\"line\">&#123;</div><div class=\"line\">    return new Promise(function (resolve, reject) &#123;</div><div class=\"line\">        log(&apos;calculating &apos; + input + &apos; x &apos; + input + &apos;...&apos;);</div><div class=\"line\">        setTimeout(resolve, 500, input * input);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">function add(input) 0.5秒后返回input+input的计算结果</div><div class=\"line\">&#123;</div><div class=\"line\">    return new Promise(function (resolve, reject) &#123;</div><div class=\"line\">        log(&apos;calculating &apos; + input + &apos; + &apos; + input + &apos;...&apos;);</div><div class=\"line\">        setTimeout(resolve, 500, input + input);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var p = new Promise(function (resolve, reject) </div><div class=\"line\">&#123;</div><div class=\"line\">    log(&apos;start new Promise...&apos;);</div><div class=\"line\">    resolve(123);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">p.then(multiply)</div><div class=\"line\"> .then(add)</div><div class=\"line\"> .then(multiply)</div><div class=\"line\"> .then(add)</div><div class=\"line\"> .then(function (result) &#123;  log(&apos;Got value: &apos; + result);  &#125; );</div></pre></td></tr></table></figure>\n</li>\n<li><p>除了串行执行若干异步任务外，Promise还可以并行执行异步任务。</p>\n</li>\n</ul>\n"}
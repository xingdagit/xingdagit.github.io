{"tags":[{"name":"JS","permalink":"http://yoursite.com/tags/JS/","url":"\\async\\tags\\JS.json","count":15}],"categories":[],"url":"\\async\\posts\\2017\\06\\04\\JS-原生JS实现AJAX.json","date":1496563612000,"path":{"year":2017,"month":6,"day":4,"name":"JS-原生JS实现AJAX"},"title":"JS-原生JS实现AJAX","permalink":"http://yoursite.com/2017/06/04/JS-原生JS实现AJAX/","content":"<h3 id=\"AJAX\"><a href=\"#AJAX\" class=\"headerlink\" title=\"AJAX\"></a>AJAX</h3><ul>\n<li>全称：Asynchronous JavaScript and XML，即用JavaScript执行<code>异步网络请求</code>。</li>\n<li>Web的运作原理为一次HTTP请求对应一个页面。如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面。这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。即在首次加载后，剩下的所有数据都依赖于AJAX来更新。 </li>\n<li>AJAX请求是异步执行的，也就是说，要通过回调函数获得响应。</li>\n<li>在现代浏览器上写AJAX主要依靠<code>XMLHttpRequest</code>对象(对于低版本的IE，需要换一个ActiveXObject对象)。</li>\n</ul>\n<h3 id=\"原生js实现ajax：\"><a href=\"#原生js实现ajax：\" class=\"headerlink\" title=\"原生js实现ajax：\"></a>原生js实现ajax：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div></pre></td><td class=\"code\"><pre><div class=\"line\">function ajax(要传到服务器端的参数) </div><div class=\"line\">&#123; </div><div class=\"line\">   var xmlHttp = null; //先声明一个异步请求对象 </div><div class=\"line\">   //实例化 </div><div class=\"line\">   try </div><div class=\"line\">   &#123; </div><div class=\"line\">      // Firefox, Opera 8.0+, Safari </div><div class=\"line\">\t  xmlHttp=new XMLHttpRequest(); </div><div class=\"line\">   &#125; </div><div class=\"line\">   catch (e) </div><div class=\"line\">   &#123; </div><div class=\"line\">      //Internet Explorer </div><div class=\"line\">\t  try </div><div class=\"line\">\t  &#123; </div><div class=\"line\">\t    xmlHttp=new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); </div><div class=\"line\">\t  &#125; </div><div class=\"line\">\t  catch (e) </div><div class=\"line\">\t  &#123; </div><div class=\"line\">\t    try </div><div class=\"line\">\t\t&#123; </div><div class=\"line\">\t\t  xmlHttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); </div><div class=\"line\">\t\t&#125; </div><div class=\"line\">\t\tcatch (e) </div><div class=\"line\">\t\t&#123; </div><div class=\"line\">\t\t  return false; //实例化失败（浏览器不支持AJAX） </div><div class=\"line\">\t\t&#125; </div><div class=\"line\">\t  &#125; </div><div class=\"line\">   &#125; </div><div class=\"line\">   if (xmlHttp==null) //若实例化失败，发出提醒 </div><div class=\"line\">   &#123; </div><div class=\"line\">     alert (&quot;Browser does not support HTTP Request&quot;); //浏览器不支持AJAX </div><div class=\"line\">\t return; </div><div class=\"line\">   &#125; </div><div class=\"line\">   /***********************************************/ </div><div class=\"line\">   xmlHttp.onreadystatechange=stateChanged; //设置onreadystatechange的回调函数(状态发生变化时，函数被回调) </div><div class=\"line\">   xmlHttp.open(&quot;GET&quot;, &quot;/api/categories&quot;); //指定GET方式， URL使用的是相对路径 </div><div class=\"line\">   //下面以请求一个php服务端为例↓ </div><div class=\"line\">   //xmlHttp.open(&quot;GET&quot;, &quot;xxx.php?形参1=&quot; + 实参1 + &quot;&amp;形参2=&quot; + 实参2 + &quot;&amp;形参n=&quot; + 实参n + ... +&quot;&amp;sid=&quot; + Math.random(), true); </div><div class=\"line\">   xmlHttp.send(null); //发送ajax请求 </div><div class=\"line\">   alert(&apos;请求已发送，请等待响应...&apos;); </div><div class=\"line\">&#125; </div><div class=\"line\">function stateChanged() //回调函数(状态发生变化时，函数被回调) </div><div class=\"line\">&#123; </div><div class=\"line\">   if (xmlHttp.readyState==4 || xmlHttp.readyState==&quot;complete&quot;)//4代表执行完成 </div><div class=\"line\">   &#123; </div><div class=\"line\">      if (xmlHttp.status === 200) // 200代表执行成功 </div><div class=\"line\">\t  &#123; </div><div class=\"line\">\t     if(xmlHttp.responseText&gt;0)//若有内容返回 </div><div class=\"line\">\t\t &#123; </div><div class=\"line\">\t\t    //可通过 xmlHttp.responseText 获取服务端返回的值</div><div class=\"line\">\t\t\t//如将服务端返回的值赋给ID为resText的元素</div><div class=\"line\">\t\t\tdocument.getElementById(&quot;resText&quot;).innerHTML = xmlHttpReg.responseText; </div><div class=\"line\">\t\t\talert(&apos;请求成功!&apos;); </div><div class=\"line\">\t\t &#125;</div><div class=\"line\">\t\t else </div><div class=\"line\">\t\t &#123; </div><div class=\"line\">\t\t   alert(&apos;无内容返回!&apos;); </div><div class=\"line\">\t\t &#125; </div><div class=\"line\">\t  &#125; </div><div class=\"line\">\t  else </div><div class=\"line\">\t  &#123; </div><div class=\"line\">\t    alert(&apos;请求失败，Error code:&apos; + xmlHttp.status); </div><div class=\"line\">\t  &#125; </div><div class=\"line\">   &#125; </div><div class=\"line\">   else </div><div class=\"line\">   &#123; </div><div class=\"line\">      //HTTP请求还在继续... </div><div class=\"line\">   &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><code>XMLHttpRequest</code>对象的<code>open()</code>方法有3个参数:<ol>\n<li>第一个参数指定发送请求所使用的方法（GET 还是 POST）。<br><code>GET</code>：更简单也更快，并且在大部分情况下都能用。<br><code>POST</code>：<br>无法使用缓存文件（更新服务器上的文件或数据库）时使用；<br>向服务器发送大量数据（POST 没有数据量限制）时使用；<br>发送包含未知字符的用户输入时，使用POST比GET更稳定也更可靠；<br>需要把body部分以字符串或FormData对象传进去。 </li>\n<li>第二个参数指定服务器端脚本的URL地址；<br>该地址的文件可以是任何类型的文件(如.txt、.xml或服务器脚本文件.asp、.php)；<br>在传回响应之前，能够在服务器上执行任务。</li>\n<li>第三个参数指定是否使用异步，默认是true，所以一般省略不写（千万不要指定为<code>false</code>，否则浏览器将停止响应，直到AJAX请求完成。如果这个请求耗时10秒，那么10秒内你会发现浏览器处于“假死”状态）。</li>\n</ol>\n</li>\n<li>代码中的URL使用的是相对路径。如果改为<code>&#39;http://www.sina.com.cn/&#39;</code>再运行肯定报错。<br>在Chrome的控制台里，还可以看到错误信息。<br>这是因为浏览器的同源策略导致的。</li>\n<li>默认情况下，JavaScript在发送AJAX请求时，URL的域名必须和当前页面(域名、协议、端口号)完全一致。</li>\n<li>当用JavaScript请求外域（其他网站）的URL时的方法：<ol>\n<li>通过Flash插件发送HTTP请求，这种方式可以绕过浏览器的安全限制，但必须安装Flash，并且跟Flash交互，而且Flash用起来麻烦；</li>\n<li>通过在同源域名下架设一个代理服务器来转发，JavaScript负责把请求发送到代理服务器：<code>&#39;/proxy?url=http://www.sina.com.cn&#39;</code>，代理服务器再把结果返回，这样就遵守了浏览器的同源策略。这种方式麻烦之处在于需要服务器端额外做开发；</li>\n<li>这种方式称为<code>JSONP</code>，它有个限制，只能用GET请求，并且要求返回JavaScript。这种方式跨域实际上是利用了浏览器允许跨域引用JavaScript资源。</li>\n</ol>\n</li>\n<li><code>send()方法</code>可将请求送往服务器。</li>\n<li><code>onreadystatechange 属性</code>存有处理服务器响应的函数。</li>\n<li><code>readyState 属性</code>存有服务器响应的状态信息。<br> 每当 readyState 改变时，onreadystatechange 函数就会被执行。</li>\n</ul>\n<h3 id=\"CORS\"><a href=\"#CORS\" class=\"headerlink\" title=\"CORS\"></a>CORS</h3><ol>\n<li>全称Cross-Origin Resource Sharing，是HTML5规范定义的跨域策略。</li>\n<li><code>Origin</code>表示本域，即浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查<code>Access-Control-Allow-Origin</code>是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。</li>\n<li>实例：假设本域是<code>my.com</code>，外域是<code>sina.com</code>，只要响应头<code>Access-Control-Allow-Origin</code>为<code>http://my.com</code>或<code>*</code>，本次请求就可以成功。如下图所示：<br><img src=\"http://www.liaoxuefeng.com/files/attachments/00143640805071744d58164a40e42ef92b9973824451595000/l\" alt=\"CORS图示\"></li>\n<li>可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的<code>Access-Control-Allow-Origin</code>，决定权始终在对方手中。</li>\n<li>这种跨域请求，称之为“简单请求”。简单请求包括<code>GET</code>、<code>HEAD</code>和<code>POST</code>（POST的Content-Type类型仅限<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>和<code>text/plain</code>），并且不能出现任何自定义头（如<code>X-Custom: 12345</code>），通常能满足90%的需求。</li>\n<li>在引用外域资源时，除了JavaScript和CSS外，都要验证<code>CORS</code>。</li>\n</ol>\n<h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><ul>\n<li>JavaScript所有代码都是单线程执行的，由于这个“缺陷”，JavaScript的所有网络操作、浏览器事件，都必须是异步执行。</li>\n<li>异步执行可以用回调函数实现：一般是在将来的某个时间点触发一个函数调用。</li>\n<li>AJAX就是典型的异步操作，但上述的AJAX代码把回调函数<code>success(request.responseText)</code>和<code>fail(request.status)</code>写到一个AJAX操作里不但不美观也不利于代码复用。</li>\n<li>于是在ES6中统一规范一个由浏览器直接支持的Promise对象，用于在将来某个时候调用相应函数。</li>\n<li>使用Promise对象可使代码先统一执行AJAX逻辑，不关心(函数)如何处理结果，然后根据结果是成功还是失败，在将来的某个时候调用<code>success</code>函数/<code>fail</code>函数。</li>\n<li><p>实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">&apos;use strict&apos;;</div><div class=\"line\">// 先清除log:</div><div class=\"line\">var logging = document.getElementById(&apos;test-promise-log&apos;);</div><div class=\"line\">while (logging.children.length &gt; 1) </div><div class=\"line\">&#123;</div><div class=\"line\">    logging.removeChild(logging.children[logging.children.length - 1]);</div><div class=\"line\">&#125;</div><div class=\"line\">// 再输出log到页面:</div><div class=\"line\">function log(s) </div><div class=\"line\">&#123;</div><div class=\"line\">  var p = document.createElement(&apos;p&apos;);</div><div class=\"line\">  p.innerHTML = s;</div><div class=\"line\">  logging.appendChild(p);</div><div class=\"line\">&#125;</div><div class=\"line\">//定义Promise对象</div><div class=\"line\">//function函数在内部异步执行，只关心自身的逻辑，并不关心resolve和reject函数具体如何处理结果</div><div class=\"line\">new Promise(function (resolve, reject) //两个参数都是函数，成功或失败时分别调用</div><div class=\"line\">&#123;</div><div class=\"line\">  log(&apos;start new Promise...&apos;);</div><div class=\"line\">  var timeOut = Math.random() * 2; //生成一个0-2之间的随机数</div><div class=\"line\">  log(&apos;set timeout to: &apos; + timeOut + &apos; seconds.&apos;);</div><div class=\"line\">  setTimeout(function () &#123;</div><div class=\"line\">      if (timeOut &lt; 1) &#123;  //如小于1则等待一段时间后调用resolve函数并返回成功</div><div class=\"line\">          log(&apos;call resolve()...&apos;);</div><div class=\"line\">          resolve(&apos;200 OK&apos;);</div><div class=\"line\">      &#125;</div><div class=\"line\">      else &#123;  //失败则调用reject函数</div><div class=\"line\">          log(&apos;call reject()...&apos;);</div><div class=\"line\">          reject(&apos;timeout in &apos; + timeOut + &apos; seconds.&apos;);</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;, timeOut * 1000);</div><div class=\"line\">&#125;).then(function (r) &#123;  //如执行成功</div><div class=\"line\">  log(&apos;Done: &apos; + r);  //获得响应内容</div><div class=\"line\">&#125;).catch(function (reason) &#123;  //如执行失败</div><div class=\"line\">  log(&apos;Failed: &apos; + reason); //获得响应代码</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>可见Promise最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离。<br><img src=\"http://www.liaoxuefeng.com/files/attachments/001436512391628944d5da9a5654a35b0ace38246f30b9c000/l\" alt=\"*\"></p>\n</li>\n<li><p>setTimeout函数可看成一个模拟网络等异步执行的函数。下面把上述AJAX异步执行函数转换为Promise对象来简化异步处理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">&apos;use strict&apos;;</div><div class=\"line\">function ajax(method, url, data) // ajax函数将返回Promise对象</div><div class=\"line\">&#123;</div><div class=\"line\">  var request = new XMLHttpRequest();</div><div class=\"line\">  return new Promise(function (resolve, reject) </div><div class=\"line\">  &#123;</div><div class=\"line\">      request.onreadystatechange = function () &#123;</div><div class=\"line\">          if (request.readyState === 4) </div><div class=\"line\">          &#123;</div><div class=\"line\">              if (request.status === 200) &#123;</div><div class=\"line\">                  resolve(request.responseText);</div><div class=\"line\">              &#125; </div><div class=\"line\">              else &#123;</div><div class=\"line\">                  reject(request.status);</div><div class=\"line\">              &#125;</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;;</div><div class=\"line\">      request.open(method, url);</div><div class=\"line\">      request.send(data);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var log = document.getElementById(&apos;test-promise-ajax-result&apos;);</div><div class=\"line\">var p = ajax(&apos;GET&apos;, &apos;/api/categories&apos;);</div><div class=\"line\">p.then(function (text) &#123; // 如果AJAX成功，获得响应内容</div><div class=\"line\">  log.innerText = text;</div><div class=\"line\">&#125;).catch(function (status) &#123; // 如果AJAX失败，获得响应代码</div><div class=\"line\">  log.innerText = &apos;ERROR: &apos; + status;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>Promise还可以做更多的事情。比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。要串行执行这样的异步任务，不用Promise则需要写一层一层的嵌套代码。有了Promise，我们只需要简单地写：<br><code>job1.then(job2).then(job3).catch(handleError);</code> //其中，job1、job2和job3都是Promise对象</p>\n</li>\n<li><p>实例：串行执行一系列需要异步计算获得结果的任务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">function multiply(input)   // 0.5秒后返回input*input的计算结果</div><div class=\"line\">&#123;</div><div class=\"line\">    return new Promise(function (resolve, reject) &#123;</div><div class=\"line\">        log(&apos;calculating &apos; + input + &apos; x &apos; + input + &apos;...&apos;);</div><div class=\"line\">        setTimeout(resolve, 500, input * input);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">function add(input) 0.5秒后返回input+input的计算结果</div><div class=\"line\">&#123;</div><div class=\"line\">    return new Promise(function (resolve, reject) &#123;</div><div class=\"line\">        log(&apos;calculating &apos; + input + &apos; + &apos; + input + &apos;...&apos;);</div><div class=\"line\">        setTimeout(resolve, 500, input + input);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var p = new Promise(function (resolve, reject) </div><div class=\"line\">&#123;</div><div class=\"line\">    log(&apos;start new Promise...&apos;);</div><div class=\"line\">    resolve(123);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">p.then(multiply)</div><div class=\"line\"> .then(add)</div><div class=\"line\"> .then(multiply)</div><div class=\"line\"> .then(add)</div><div class=\"line\"> .then(function (result) &#123;  log(&apos;Got value: &apos; + result);  &#125; );</div></pre></td></tr></table></figure>\n</li>\n<li><p>除了串行执行若干异步任务外，Promise还可以并行执行异步任务。</p>\n</li>\n</ul>\n"}
{"tags":[{"name":"设计模式","permalink":"http://yoursite.com/tags/设计模式/","url":"\\async\\tags\\设计模式.json","count":7}],"categories":[],"url":"\\async\\posts\\2017\\06\\24\\设计模式-装饰模式Decorator.json","date":1498275102000,"path":{"year":2017,"month":6,"day":24,"name":"设计模式-装饰模式Decorator"},"title":"设计模式-装饰模式Decorator","permalink":"http://yoursite.com/2017/06/24/设计模式-装饰模式Decorator/","content":"<h3 id=\"一、装饰模式-Decorator-Pattern\"><a href=\"#一、装饰模式-Decorator-Pattern\" class=\"headerlink\" title=\"一、装饰模式(Decorator Pattern)\"></a>一、装饰模式(Decorator Pattern)</h3><ul>\n<li>装饰模式属于结构型模式。</li>\n</ul>\n<h3 id=\"二、模式动机\"><a href=\"#二、模式动机\" class=\"headerlink\" title=\"二、模式动机\"></a>二、模式动机</h3><ul>\n<li>在现实生活中，可给照片加一个边框而不改变照片本身，而且可根据需要增加不同类型的边框，还可以继续加边框。<br>新房的装修也是类似。</li>\n<li>在软件设计中，也可以用类似的技术对原有对象的功能进行扩展，以获得更加符合用户需求的对象。<br>这种技术在设计模式中称为<code>装饰模式</code>，装饰模式可在不改变一个对象本身的基础上给对象增加额外的新行为。</li>\n<li>一般有两种方式可以实现<code>给一个类或对象增加行为</code>：<ol>\n<li><code>继承机制</code><br>通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。<br>但是这种方法是<code>静态的</code>，用户不能控制增加行为的方式和时机。</li>\n<li><code>关联机制</code><br>即将一个类的对象嵌入另一个对象中，<code>由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为</code>，<br>我们称这个嵌入的对象为<code>装饰器</code>。 </li>\n</ol>\n</li>\n<li>装饰模式<code>以对客户透明的方式动态地给一个对象附加上更多的责任</code>（因为具体构件类和装饰类都实现了相同的抽象构件接口），<br>即客户端并不会觉得对象在装饰前和装饰后有什么不同。</li>\n<li>装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。<br>这就是装饰模式的模式动机。</li>\n</ul>\n<h3 id=\"三、模式定义\"><a href=\"#三、模式定义\" class=\"headerlink\" title=\"三、模式定义\"></a>三、模式定义</h3><blockquote>\n<p>装饰模式(Decorator Pattern)：动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。</p>\n</blockquote>\n<h3 id=\"四、模式结构\"><a href=\"#四、模式结构\" class=\"headerlink\" title=\"四、模式结构\"></a>四、模式结构</h3><ul>\n<li><p>装饰模式结构图<br><img src=\"https://ooo.0o0.ooo/2017/06/24/594dfa54abc30.jpg\" alt=\"装饰模式结构图\"></p>\n</li>\n<li><p>在装饰模式结构图中包含如下几个角色：</p>\n</li>\n</ul>\n<ol>\n<li>Component（抽象构件）：<br>它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，<br>它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。</li>\n<li>ConcreteComponent（具体构件）：<br>它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，<br>装饰器可以给它增加额外的职责（方法）。</li>\n<li>Decorator（抽象装饰类）：<br>它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。<br>它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。</li>\n<li>ConcreteDecorator（具体装饰类）：<br>它是抽象装饰类的子类，负责向构件添加新的职责。<br>每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。</li>\n</ol>\n<h3 id=\"五、模式分析\"><a href=\"#五、模式分析\" class=\"headerlink\" title=\"五、模式分析\"></a>五、模式分析</h3><ul>\n<li>我们知道对类功能进行扩展时应多用关联关系，少用继承关系。<br>与继承关系相比，关联关系的主要优势在于<code>不会破坏类的封装性</code>，而且<code>继承是一种耦合度较大的静态关系，无法在程序运行时动态扩展</code>。</li>\n<li>由于关联关系使系统具有较好的<code>松耦合性</code>，从而使得系统更加容易维护，<br>因此使用装饰模式实现扩展比继承更加灵活。<br>当然，关联关系的缺点是比继承关系要创建更多的对象。</li>\n<li>装饰模式是一种用于替代继承的技术，它通过一种无须定义子类的方式来给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系。</li>\n<li>在装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩充原有类的功能。</li>\n<li>装饰模式降低了系统的耦合度，可以动态增加或删除对象的职责，并使得需要装饰的具体构件类和具体装饰类可以独立变化，以便增加新的具体构件类和具体装饰类，满足”开闭原则”的要求。</li>\n<li><p>装饰模式的核心在于抽象装饰类的设计，典型的<code>抽象装饰类</code>代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">//抽象装饰类</div><div class=\"line\">public class Decorator implements Component</div><div class=\"line\">&#123;</div><div class=\"line\">    private Component component;  //维持一个对抽象构件对象的引用</div><div class=\"line\">    public Decorator(Component component) //构造方法</div><div class=\"line\">\t&#123;</div><div class=\"line\">        this.component=component;//注入一个抽象构件类型的对象</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    public void operation()</div><div class=\"line\">\t&#123;</div><div class=\"line\">        component.operation();  //调用原有component对象的业务方法</div><div class=\"line\">    &#125;</div><div class=\"line\">\t//在Decorator中并未真正实现operation()方法，而只是调用原有component对象的operation()方法。</div><div class=\"line\">\t//它没有真正实施装饰，而是提供一个统一的接口，将具体装饰过程交给子类完成。</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>在Decorator的子类即具体装饰类中将继承operation()方法并根据需要进行扩展，典型的<code>具体装饰类</code>代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">//具体装饰类</div><div class=\"line\">public class ConcreteDecorator extends Decorator</div><div class=\"line\">&#123;</div><div class=\"line\">    public ConcreteDecorator(Component  component)&#123;</div><div class=\"line\">        super(component);</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    public void operation()//扩展(定义了新方法)</div><div class=\"line\">\t&#123;</div><div class=\"line\">        super.operation(); //调用原有业务方法</div><div class=\"line\">        addedBehavior();   //调用新增业务方法</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    //新增业务方法</div><div class=\"line\">\tpublic  void addedBehavior()&#123;    </div><div class=\"line\">        ……</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>由于在抽象装饰类Decorator中注入的是Component类型的对象，因此我们可以将一个具体构件对象注入其中，再通过具体装饰类来进行装饰；<br>此外，我们还可以将一个已经装饰过的Decorator子类的对象再注入其中进行多次装饰，从而对原有功能的多次扩展。</p>\n</li>\n</ul>\n<h3 id=\"六、知识点\"><a href=\"#六、知识点\" class=\"headerlink\" title=\"六、知识点\"></a>六、知识点</h3><ul>\n<li><p>装饰模式的主要优点如下：<br>(1) 对于扩展一个对象的功能，装饰模式比继承更加灵活性，不会导致类的个数急剧增加。<br>(2) 可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的具体装饰类，从而实现不同的行为。<br>(3) 可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，得到功能更为强大的对象。<br>(4) 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合“开闭原则”。</p>\n</li>\n<li><p>装饰模式的主要缺点如下：<br>(1) 使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，大量小对象的产生势必会占用更多的系统资源，在一定程序上影响程序的性能。<br>(2) 装饰模式提供了一种比继承更加灵活机动的解决方案，但同时也意味着比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐。</p>\n</li>\n<li><p>适用场景<br>(1) 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。<br>(2) 当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种扩展或者扩展之间的组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类已定义为不能被继承（如Java语言中的final类）。</p>\n</li>\n<li><p>模式应用<br>(1) 类似变形金刚的多功能系统<br>(2) 多重加密系统<br>(3) JavaIO中的输入流和输出流的设计<br>(4) javax.swing包中一些图形界面构件功能的增强与改善</p>\n</li>\n</ul>\n<h3 id=\"七、透明装饰模式与半透明装饰模式\"><a href=\"#七、透明装饰模式与半透明装饰模式\" class=\"headerlink\" title=\"七、透明装饰模式与半透明装饰模式\"></a>七、透明装饰模式与半透明装饰模式</h3><p>1.透明装饰模式</p>\n<ul>\n<li>如果具体装饰类以<code>在其operation()方法中除调用原有对象的operation()外还调用新增的addedBehavior()方法来覆盖抽象装饰类operation()方法</code>的方式来实现增加新行为，<br>使客户端可统一通过operation()方法来使用新行为，<br>则客户端可以用抽象构件类型来定义具体构件对象和具体装饰对象，还可以将已有具体装饰类对象作为新的具体构件对象继续进行多次装饰，得到更为复杂、功能更为强大的对象。<br>这种方式称为<code>透明装饰模式</code>，也是标准的装饰模式。</li>\n<li>在透明装饰模式中，要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该将对象声明为具体构件类型或具体装饰类型，而应该全部声明为抽象构件类型。<br>即客户端可透明地使用装饰之前的对象和装饰之后的对象，无须关心它们的区别（对于客户端而言具体构件对象和具体装饰对象没有任何区别）。</li>\n<li><p>也就是应该使用如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Component c, c1; //使用抽象构件类型定义对象</div><div class=\"line\">c = new ConcreteComponent()；</div><div class=\"line\">c1 = new ConcreteDecorator (c)；</div></pre></td></tr></table></figure>\n</li>\n<li><p>而不应该使用如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ConcreteComponent c; //使用具体构件类型定义对象 </div><div class=\"line\">c = new ConcreteComponent()； </div><div class=\"line\">或 </div><div class=\"line\">ConcreteDecorator c1; //使用具体装饰类型定义对象 </div><div class=\"line\">c1 = new ConcreteDecorator(c)；</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>2.半透明装饰模式(常用)</p>\n<ul>\n<li>如果用具体装饰类型来定义装饰之后的对象，而具体构件类型还是使用抽象构件类型来定义，<br>即具体装饰类将增加的addedBehavior()方法独立封装，并作为一个单独的方法提供给客户端使用，客户端不能使用抽象构件来定义具体装饰对象，也不能进行多重装饰。<br>由于客户端使用具体装饰类型来定义装饰后的对象，因此单独调用addedBehavior()方法就可以扩展系统功能。<br>也就是说，对于客户端而言具体构件类型无须关心，是透明的；但具体装饰类型必须指定，这是不透明的。<br>这种方式称为<code>半透明装饰模式</code>。</li>\n<li><p>客户端代码示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">……</div><div class=\"line\">Document  doc; //使用抽象构件类型定义</div><div class=\"line\">doc = new PurchaseRequest();</div><div class=\"line\">Approver newDoc; //使用具体装饰类型定义</div><div class=\"line\">newDoc = new Approver(doc);</div><div class=\"line\">……</div></pre></td></tr></table></figure>\n</li>\n<li><p>半透明装饰模式可以给系统带来更多的灵活性，设计相对简单，使用起来也非常方便；<br>但是其最大的缺点在于不能实现对同一个对象的多次装饰，而且客户端需要有区别地对待装饰之前的对象和装饰之后的对象。</p>\n</li>\n<li>在实际使用过程中由于新增行为可能需要单独调用，因此大多数装饰模式都是半透明装饰模式</li>\n</ul>\n<h3 id=\"八、装饰模式的简化\"><a href=\"#八、装饰模式的简化\" class=\"headerlink\" title=\"八、装饰模式的简化\"></a>八、装饰模式的简化</h3><p>大多数情况下，装饰模式的实现比标准的结构图要简单，可以对装饰模式进行简化。<br>在简化过程中需要注意如下几个问题：<br>(1) 尽量保持装饰类的接口与被装饰类的接口相同，这样，对于客户端而言，无论是装饰之前的对象还是装饰之后的对象都可以一致对待。这也就是说，在可能的情况下，我们应该尽量使用透明装饰模式。<br>(2) 尽量保持具体构件类ConcreteComponent是一个“轻”类，也就是说不要把太多的行为放在具体构件类中，我们可以通过装饰类对其进行扩展。<br>(3) <code>如果只有一个具体构件类而没有抽象构件类，那么可以把抽象装饰类和具体装饰类的职责合并到一个类中，即抽象装饰类可以作为该具体构件类的直接子类</code>。<br>没有抽象构件类的装饰模式如下图所示<br><img src=\"https://ooo.0o0.ooo/2017/06/24/594e19b263204.jpg\" alt=\"没有抽象构件类的装饰模式\"></p>\n<h3 id=\"九、重要实例1\"><a href=\"#九、重要实例1\" class=\"headerlink\" title=\"九、重要实例1\"></a>九、重要实例1</h3><ul>\n<li>要求：<br>某系统提供了一个数据加密功能，可以对字符串进行加密。<br>最简单的加密算法通过对字母进行移位来实现，同时还提供了稍复杂的逆向输出加密，还提供了更为高级的求模加密。<br>用户先使用最简单的加密算法对字符串进行加密，如果觉得还不够可以对加密之后的结果使用其他加密算法进行二次加密，当然也可以进行第三次加密。<br>现使用装饰模式设计该多重加密系统。</li>\n<li><img src=\"https://ooo.0o0.ooo/2017/06/24/594e130e53167.jpg\" alt=\"多重加密系统类图\"></li>\n<li><p>解决代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div></pre></td><td class=\"code\"><pre><div class=\"line\">//抽象加密类：抽象构件类</div><div class=\"line\">interface Cipher</div><div class=\"line\">&#123;</div><div class=\"line\">\tpublic String encrypt(String plainText);//声明加密方法</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//简单加密类：具体构件类</div><div class=\"line\">class SimpleCipher implements Cipher</div><div class=\"line\">&#123;</div><div class=\"line\">    //以凯撒加密的方式实现加密方法encrypt()</div><div class=\"line\">\tpublic String encrypt(String plainText)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tString str=&quot;&quot;;</div><div class=\"line\">\t\tfor(int i=0;i&lt;plainText.length();i++)</div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\tchar c=plainText.charAt(i);</div><div class=\"line\">\t\t\tif(c&gt;=&apos;a&apos;&amp;&amp;c&lt;=&apos;z&apos;)</div><div class=\"line\">\t\t\t&#123;</div><div class=\"line\">\t\t\t\tc+=6;</div><div class=\"line\">\t\t\tif(c&gt;&apos;z&apos;) c-=26;</div><div class=\"line\">\t\t\tif(c&lt;&apos;a&apos;) c+=26;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tif(c&gt;=&apos;A&apos;&amp;&amp;c&lt;=&apos;Z&apos;)</div><div class=\"line\">\t\t\t&#123;</div><div class=\"line\">\t\t\t\tc+=6;</div><div class=\"line\">\t\t\tif(c&gt;&apos;Z&apos;) c-=26;</div><div class=\"line\">\t\t\tif(c&lt;&apos;A&apos;) c+=26;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tstr+=c;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\treturn str;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//加密装饰类：抽象装饰类</div><div class=\"line\">class CipherDecorator implements Cipher</div><div class=\"line\">&#123;</div><div class=\"line\">\tprivate Cipher cipher; /定义一个抽象构件Cipher类型的对象cipher</div><div class=\"line\">\t</div><div class=\"line\">\tpublic CipherDecorator(Cipher cipher)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tthis.cipher=cipher;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tpublic String encrypt(String plainText)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\treturn cipher.encrypt(plainText);//调用cipher对象的encrypt()方法</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//复杂加密类：具体装饰类</div><div class=\"line\">class ComplexCipher extends CipherDecorator</div><div class=\"line\">&#123;</div><div class=\"line\">\tpublic ComplexCipher(Cipher cipher)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tsuper(cipher);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tpublic String encrypt(String plainText)//覆盖抽象装饰类的encrypt()方法</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tString result=super.encrypt(plainText);//调用父类的encrypt()方法</div><div class=\"line\">\t\tresult=reverse(result);//并通过新增的reverse()方法对加密之后的字符串进行进一步处理</div><div class=\"line\">\t\treturn result;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tpublic String reverse(String text)//新增一个实现逆向输出的方法</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tString str=&quot;&quot;;</div><div class=\"line\">\t\tfor(int i=text.length();i&gt;0;i--)</div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\tstr+=text.substring(i-1,i);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\treturn str;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//高级加密类：具体装饰类</div><div class=\"line\">class AdvancedCipher extends CipherDecorator</div><div class=\"line\">&#123;</div><div class=\"line\">\tpublic AdvancedCipher(Cipher cipher)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tsuper(cipher);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tpublic String encrypt(String plainText)//覆盖抽象装饰类的encrypt()方法</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tString result=super.encrypt(plainText);//调用父类的encrypt()方法</div><div class=\"line\">\t\tresult=mod(result); //并通过新增的mod()方法对加密结果进行进一步处理</div><div class=\"line\">\t\treturn result;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tpublic String mod(String text)//新增一个实现求模加密的方法</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tString str=&quot;&quot;;</div><div class=\"line\">\t\tfor(int i=0;i&lt;text.length();i++)</div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\tString c=String.valueOf(text.charAt(i)%6);</div><div class=\"line\">\t\t\tstr+=c;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\treturn str;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//客户端测试类</div><div class=\"line\">class Client</div><div class=\"line\">&#123;</div><div class=\"line\">\tpublic static void main(String args[])</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tString password=&quot;sunnyLiu&quot;;  //明文</div><div class=\"line\">\t\tString cpassword;       //密文</div><div class=\"line\">\t\tCipher sc,cc;  //全部使用抽象构件类型定义对象（透明装饰模式）</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tsc=new SimpleCipher();</div><div class=\"line\">\t\tcpassword=sc.encrypt(password);</div><div class=\"line\">\t\tSystem.out.println(cpassword);</div><div class=\"line\">\t\tSystem.out.println(&quot;---------------------&quot;);</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tcc=new ComplexCipher(sc);</div><div class=\"line\">\t\tcpassword=cc.encrypt(password);</div><div class=\"line\">\t    System.out.println(cpassword);</div><div class=\"line\">\t\tSystem.out.println(&quot;---------------------&quot;);</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t/*</div><div class=\"line\">\t\tac=new AdvancedCipher(cc);</div><div class=\"line\">\t\tcpassword=ac.encrypt(password);</div><div class=\"line\">\t    System.out.println(cpassword);</div><div class=\"line\">\t\tSystem.out.println(&quot;---------------------&quot;);</div><div class=\"line\">\t\t*/</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">yatteRoa</div><div class=\"line\">---------------------</div><div class=\"line\">aoRettay</div><div class=\"line\">---------------------</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"十、重要实例2\"><a href=\"#十、重要实例2\" class=\"headerlink\" title=\"十、重要实例2\"></a>十、重要实例2</h3><ul>\n<li>要求：<br>某软件公司基于面向对象技术开发了一套图形界面构件库VisualComponent。<br>该构件库提供了大量基本构件，如窗体等。<br>使用该构件库时，用户可要求为界面定制一些特效显示效果，如带滚动条的窗体、透明的窗体、或者既带滚动条又透明的窗体等等，<br>因此经常需要对该构件库进行扩展以增强其功能，<br>请使用装饰模式设计该构件库，并写出相应Java代码。</li>\n<li><img src=\"https://ooo.0o0.ooo/2017/06/24/594e1867a08b4.jpg\" alt=\"图形界面构件库类图\"></li>\n<li><p>解决代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div></pre></td><td class=\"code\"><pre><div class=\"line\">//抽象窗体类：抽象构件类</div><div class=\"line\">abstract class Window</div><div class=\"line\">&#123;</div><div class=\"line\">\tpublic abstract void display();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//简单窗体类：具体构件类</div><div class=\"line\">class SimpleWindow extends Window</div><div class=\"line\">&#123;</div><div class=\"line\">\tpublic void display()&#123;</div><div class=\"line\">\t\tSystem.out.println(&quot;显示窗体&quot;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//窗体装饰类：抽象装饰者类</div><div class=\"line\">class WindowDecorator extends Window</div><div class=\"line\">&#123;</div><div class=\"line\">\tprivate Window window;    //维持对抽象构件类型对象的引用</div><div class=\"line\">\tpublic WindowDecorator(Window window)//注入抽象构件类型的对象</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tthis.window=window;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic void display()</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\twindow.display();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//滚动条窗体装饰类：具体装饰者类</div><div class=\"line\">class ScrollbarDecorator extends WindowDecorator</div><div class=\"line\">&#123;</div><div class=\"line\">\tpublic ScrollbarDecorator(Window window)&#123;</div><div class=\"line\">\t\tsuper(window);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic void setScrollbar()</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tSystem.out.println(&quot;给窗口增加一个滚动条！&quot;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic void display()</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tthis.setScrollbar();</div><div class=\"line\">\t\tsuper.display();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//透明窗体装饰类：具体装饰者类</div><div class=\"line\">class TransparentDecorator extends WindowDecorator&#123;</div><div class=\"line\">\tpublic TransparentDecorator(Window window)&#123;</div><div class=\"line\">\t\tsuper(window);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic void setTransparent()&#123;</div><div class=\"line\">\t\tSystem.out.println(&quot;设置窗体透明！&quot;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tpublic void display()&#123;</div><div class=\"line\">\t\tthis.setTransparent();</div><div class=\"line\">\t\tsuper.display();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//客户端测试类</div><div class=\"line\">class Client</div><div class=\"line\">&#123;</div><div class=\"line\">\tpublic static void main(String args[])</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t    //全部使用抽象构件类型定义对象（透明装饰模式）</div><div class=\"line\">\t\tWindow windowS, windowSB, windowT;</div><div class=\"line\">\t\twindowS=new SimpleWindow();</div><div class=\"line\">\t\twindowT=new TransparentDecorator(windowS);</div><div class=\"line\">\t\t//将装饰了一次之后的对象继续注入到另一个装饰类中</div><div class=\"line\">\t\twindowSB=new ScrollbarDecorator(windowT);</div><div class=\"line\">\t\twindowSB.display();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">给窗口增加一个滚动条！</div><div class=\"line\">设置窗体透明！</div><div class=\"line\">显示窗体</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>【参考】(作者：刘伟 <a href=\"http://blog.csdn.net/lovelion\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/lovelion</a>)</p>\n"}
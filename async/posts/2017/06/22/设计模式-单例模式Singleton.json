{"tags":[{"name":"设计模式","permalink":"http://yoursite.com/tags/设计模式/","url":"\\async\\tags\\设计模式.json","count":12}],"categories":[],"url":"\\async\\posts\\2017\\06\\22\\设计模式-单例模式Singleton.json","date":1498139423000,"path":{"year":2017,"month":6,"day":22,"name":"设计模式-单例模式Singleton"},"title":"设计模式-单例模式Singleton","permalink":"http://yoursite.com/2017/06/22/设计模式-单例模式Singleton/","content":"<h3 id=\"一、单例模式-Singleton-Pattern\"><a href=\"#一、单例模式-Singleton-Pattern\" class=\"headerlink\" title=\"一、单例模式(Singleton Pattern)\"></a>一、单例模式(Singleton Pattern)</h3><ul>\n<li>单例模式属于创建型模式。</li>\n<li>单例模式是所有设计模式中结构最为简单的模式，它只包含一个类，即单例类。</li>\n<li>实例具有唯一性。</li>\n</ul>\n<h3 id=\"二、模式动机\"><a href=\"#二、模式动机\" class=\"headerlink\" title=\"二、模式动机\"></a>二、模式动机</h3><ul>\n<li>对于系统中的某些类来说，只有一个实例很重要。</li>\n<li>如一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；<br>如一个系统只能有一个文件系统；<br>如一个系统只能有一个计时工具或ID（序号）生成器；<br>如在Windows系统中始终只能弹出一个任务管理器窗口，也就是说在一个Windows系统中，任务管理器存在唯一性。</li>\n<li>以Windows系统的任务管理器窗口为例，<br>若不使用机制对窗口对象进行唯一化，将弹出多个重复的窗口对象，浪费内存资源；<br>若弹出的多个任务管理器不重复，意味着某瞬间系统有多个状态，这与实际不符；<br>因此，有时候确保系统中的某个对象的唯一性即一个类只能有一个实例很重要。</li>\n<li>为节约系统资源，有时需确保系统中某个类只有唯一一个实例，<br>那么如何保证一个类只有一个实例并且这个实例易于被访问呢？<br>1.定义一个全局变量确保对象随时都可被访问，但不能防止我们实例化多个对象。<br>2.一个更好的解决办法是<code>让类自身负责保存它的唯一实例</code>。<br>当其唯一实例创建成功后，这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法，所有的操作都只能基于这个唯一实例。这就是单例模式的动机所在。</li>\n</ul>\n<h3 id=\"三、模式定义\"><a href=\"#三、模式定义\" class=\"headerlink\" title=\"三、模式定义\"></a>三、模式定义</h3><blockquote>\n<p>单例模式(Singleton Pattern)：确保在系统中某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。</p>\n</blockquote>\n<ul>\n<li>单例模式有三个要点<br>（1）<code>某个类只能有一个实例</code>；<br>（2）<code>它必须自行创建这个实例</code>；<br>（3）<code>它必须自行向整个系统提供这个实例</code>。</li>\n</ul>\n<h3 id=\"四、模式结构\"><a href=\"#四、模式结构\" class=\"headerlink\" title=\"四、模式结构\"></a>四、模式结构</h3><ul>\n<li><p>单例模式结构图<br><img src=\"https://ooo.0o0.ooo/2017/06/22/594bd450b7650.jpg\" alt=\"单例模式结构图\"></p>\n</li>\n<li><p>单例模式结构图中只包含一个单例角色：</p>\n</li>\n</ul>\n<ol>\n<li>Singleton（单例类）：<br>在单例类的内部实现<code>只生成一个实例</code>，<br>同时它提供一个<code>静态的getInstance()工厂方法</code>，让客户可以访问它的唯一实例；<br>为了防止在外部对其实例化，将其构造函数设计为<code>私有</code>；<br>在单例类内部定义了一个<code>Singleton类型的静态对象</code>，作为外部共享的<code>唯一实例</code>。</li>\n</ol>\n<h3 id=\"五、模式分析\"><a href=\"#五、模式分析\" class=\"headerlink\" title=\"五、模式分析\"></a>五、模式分析</h3><ul>\n<li>单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。</li>\n<li>单例模式包含的角色只有一个，就是单例类—Singleton。</li>\n<li>单例类拥有一个<code>私有构造函数</code>，确保用户无法通过new关键字直接实例化它。<br>除此之外，该模式中包含一个<code>静态私有成员变量</code>与<code>静态公有的工厂方法</code>，该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。</li>\n<li><p>一般情况下单例模式的实现代码如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Singleton </div><div class=\"line\">&#123; </div><div class=\"line\">   private static Singleton instance=null; //静态私有成员变量 </div><div class=\"line\">   </div><div class=\"line\">   private Singleton()&#123; &#125; //私有构造函数 </div><div class=\"line\">   </div><div class=\"line\">   public static Singleton getInstance( ) //静态公有工厂方法，实例化并返回唯一实例 </div><div class=\"line\">   &#123; </div><div class=\"line\">      if(instance==null) </div><div class=\"line\">\t    instance=new Singleton(); //实例化后存储在静态成员变量中，以确保只有一个实例被创建 </div><div class=\"line\">\t  return instance; </div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>总之，在单例模式的实现过程中，需要注意如下三点：<br>（1）单例类的构造函数为私有；<br>（2）提供一个私有的静态私有成员变量；<br>（3）提供一个公有的静态工厂方法。</p>\n</li>\n</ul>\n<h3 id=\"六、知识点\"><a href=\"#六、知识点\" class=\"headerlink\" title=\"六、知识点\"></a>六、知识点</h3><ul>\n<li><p>优点：<br>(1) 单例模式提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。<br>(2) 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。<br>(3) 允许可变数目的实例。基于单例模式我们可以进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例，既节省系统资源，又解决了单例单例对象共享过多有损性能的问题。</p>\n</li>\n<li><p>缺点：<br>(1) 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。<br>(2) 单例类的职责过重，在一定程度上<code>违背了“单一职责原则”</code>。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。<br>(3) 现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的共享对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致共享的单例对象状态的丢失。</p>\n</li>\n<li><p>适用场景<br>(1) 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。<br>(2) 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</p>\n</li>\n<li><p>模式应用<br>(1) Window系统任务管理器<br>(2) 分配身份证号码<br>(3) 打印池的设计<br>(4) Java语言类库JDK中有很多单例模式的应用实例(如java.lang.Runtime类)<br>(5) 数据库表中须保证主键唯一性的主键编号生成器<br>(6) Java EE框架 Spring 通过单例模式创建类的实例</p>\n</li>\n</ul>\n<h3 id=\"七、关于饿汉式单例与懒汉式单例\"><a href=\"#七、关于饿汉式单例与懒汉式单例\" class=\"headerlink\" title=\"七、关于饿汉式单例与懒汉式单例\"></a>七、关于饿汉式单例与懒汉式单例</h3><p><strong>饿汉式单例类</strong><br>饿汉式单例类是在Java语言中实现起来最为方便的单例类，其结构图如下：<br><img src=\"https://ooo.0o0.ooo/2017/06/22/594be57503d30.jpg\" alt=\"饿汉式单例类结构图\"><br>从图中可看出，由于在定义静态变量的时候实例化单例类，因此<code>在类加载的时候就已经创建了单例对象</code>，代码如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">class EagerSingleton </div><div class=\"line\">&#123;   </div><div class=\"line\">    private static final EagerSingleton instance = new EagerSingleton(); </div><div class=\"line\">\t</div><div class=\"line\">\tprivate EagerSingleton() &#123; &#125;   </div><div class=\"line\">  </div><div class=\"line\">    public static EagerSingleton getInstance() &#123;  </div><div class=\"line\">        return instance;   </div><div class=\"line\">    &#125;     </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>当类被加载时，静态变量instance会被初始化，此时类的私有构造函数会被调用，单例类的唯一实例将被创建。<br>使用饿汉式单例可确保单例对象的唯一性，不会出现创建多个单例对象的情况。</p>\n<p><strong>懒汉式单例类</strong><br>懒汉式单例类的构造函数也是私有的（这点与饿汉式单例类相同）<br>但懒汉式单例类<code>在第一次被引用时才将自己实例化，而之后在类加载时不会将自己实例化</code>。<br><img src=\"https://ooo.0o0.ooo/2017/06/22/594be48c92429.jpg\" alt=\"懒汉式单例类结构图\"><br>从图中可看出，懒汉式单例类在第一次调用getInstance()方法时实例化，在类加载时并不自行实例化，这种技术又称为延迟加载(Lazy Load)技术，即需要的时候再加载实例。<br>为了避免多个线程同时调用getInstance()方法，我们可以使用<code>关键字synchronized</code>，代码如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">class LazySingleton </div><div class=\"line\">&#123; </div><div class=\"line\">  private static LazySingleton instance = null; </div><div class=\"line\">  </div><div class=\"line\">  private LazySingleton() &#123; &#125; </div><div class=\"line\">  </div><div class=\"line\">  synchronized public static LazySingleton getInstance() </div><div class=\"line\">  &#123; </div><div class=\"line\">    if (instance == null) </div><div class=\"line\">\t&#123; </div><div class=\"line\">\t  instance = new LazySingleton(); </div><div class=\"line\">\t&#125; </div><div class=\"line\">\treturn instance; </div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>该懒汉式单例类在getInstance()方法前面增加了关键字synchronized进行线程锁，以处理多个线程同时访问的问题。虽然解决了线程安全问题，但每次调用getInstance()时都需要进行线程锁定判断，在多线程高并发访问环境中，将会导致系统性能大大降低。<br>如何既解决线程安全问题又不影响系统性能呢？我们继续对懒汉式单例进行改进。<br>事实上，我们无须对整个getInstance()方法进行锁定，只需对其中的代码<code>instance = new LazySingleton();</code>进行锁定即可。<br>因此getInstance()方法可以进行如下改进：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static LazySingleton getInstance() </div><div class=\"line\">&#123; </div><div class=\"line\">  if (instance == null) </div><div class=\"line\">  &#123; </div><div class=\"line\">    synchronized (LazySingleton.class) </div><div class=\"line\">\t&#123; </div><div class=\"line\">\t  instance = new LazySingleton(); </div><div class=\"line\">    &#125; </div><div class=\"line\">  &#125; </div><div class=\"line\">  return instance; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>问题貌似得以解决，事实并非如此。如果使用以上代码来实现单例，还是会存在单例对象不唯一的情况。<br>原因如下：<br>假如在某一瞬间线程A和线程B都在调用getInstance()方法，此时instance对象为null值，均能通过instance == null的判断。<br>由于实现了synchronized加锁机制，线程A进入synchronized锁定的代码中执行实例创建代码，线程B处于排队等待状态，必须等待线程A执行完毕后才可以进入synchronized锁定代码。<br>但当A执行完毕时，线程B并不知道实例已经创建，将继续创建新的实例，导致产生多个单例对象，违背单例模式的设计思想。<br>因此需要进行进一步改进，在synchronized中再进行一次(instance == null)判断，这种方式称为<code>双重检查锁定(Double-Check Locking)</code>。<br>使用双重检查锁定实现的懒汉式单例类完整代码如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">class LazySingleton </div><div class=\"line\">&#123; </div><div class=\"line\">  private volatile static LazySingleton instance = null; </div><div class=\"line\">  </div><div class=\"line\">  private LazySingleton() &#123; &#125; </div><div class=\"line\">  </div><div class=\"line\">  public static LazySingleton getInstance() </div><div class=\"line\">  &#123; </div><div class=\"line\">    if (instance == null) //第一重判断 </div><div class=\"line\">\t&#123; </div><div class=\"line\">\t  //锁定代码块 </div><div class=\"line\">\t  synchronized (LazySingleton.class) </div><div class=\"line\">\t  &#123; </div><div class=\"line\">\t    if (instance == null) //第二重判断 </div><div class=\"line\">\t\t&#123; </div><div class=\"line\">\t\t   instance = new LazySingleton(); //创建单例实例 </div><div class=\"line\">\t\t&#125; </div><div class=\"line\">\t  &#125; </div><div class=\"line\">\t&#125; </div><div class=\"line\">\treturn instance; </div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>需要注意的是，如果使用双重检查锁定来实现懒汉式单例类，需要在静态成员变量instance之前增加<code>修饰符volatile</code>，被volatile修饰的成员变量可以确保多个线程都能够正确处理，且该代码只能在JDK 1.5及以上版本中才能正确执行。<br>由于volatile关键字会屏蔽Java虚拟机所做的一些代码优化，可能会导致系统运行效率降低，因此即使使用双重检查锁定来实现单例模式也不是一种完美的实现方式。 </p>\n<p><strong>饿汉式单例类与懒汉式单例类比较</strong></p>\n<ul>\n<li>饿汉式单例类在类被加载时就将自己实例化，它的优点在于无须考虑多线程访问问题，可以确保实例的唯一性；从调用速度和反应时间角度来讲，由于单例对象一开始就得以创建，因此要优于懒汉式单例。但是无论系统在运行时是否需要使用该单例对象，由于在类加载时该对象就需要创建，因此从资源利用效率角度来讲，饿汉式单例不及懒汉式单例，而且在系统加载时由于需要创建饿汉式单例对象，加载时间可能会比较长。</li>\n<li>懒汉式单例类在第一次使用时才创建，无须一直占用系统资源，实现了延迟加载，但是必须处理好多个线程同时访问的问题，特别是当单例类作为资源控制器，在实例化时必然涉及资源初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的机率变得较大，需要通过双重检查锁定等机制进行控制，这将导致系统性能受到一定影响。</li>\n<li>资源利用效率：饿汉式单例类 <code>差于</code> 懒汉式单例类</li>\n<li>速度和反应时间：饿汉式单例类 <code>优于</code> 懒汉式单例类</li>\n</ul>\n<h3 id=\"八、重要实例\"><a href=\"#八、重要实例\" class=\"headerlink\" title=\"八、重要实例\"></a>八、重要实例</h3><ul>\n<li><p>要求：<br>在现实生活中，居民身份证号码具有唯一性，同一个人不允许有多个身份证号码。<br>第一次申请身份证时将给居民分配一个身份证号码，<br>如果之后因为遗失等原因补办时，还是使用原来的身份证号码，不会产生新的号码。<br>现使用单例模式模拟该场景。 </p>\n</li>\n<li><p>模式结构分析图<br><img src=\"https://ooo.0o0.ooo/2017/06/22/594bdace5fed0.jpg\" alt=\"模式结构分析图\"></p>\n</li>\n<li><p>解决代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">class IdentityCardNo </div><div class=\"line\">&#123;</div><div class=\"line\">\t// 被volatile修饰的成员变量可确保多个线程能够正确处理</div><div class=\"line\">\tprivate volatile static IdentityCardNo instance=null; //静态私有成员变量 </div><div class=\"line\">\tprivate String no;</div><div class=\"line\">\t</div><div class=\"line\">\tprivate IdentityCardNo()&#123;&#125; //私有构造函数 </div><div class=\"line\">\t</div><div class=\"line\">\t// 双重检查锁定（double check locking）</div><div class=\"line\">\tpublic static IdentityCardNo getInstance() //静态公有工厂方法，返回唯一实例 </div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tif(instance==null)// 第一重判断</div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\tsynchronized (IdentityCardNo.class)// 锁定代码块</div><div class=\"line\">\t\t\t&#123;</div><div class=\"line\">\t\t\t\tif(instance==null) // 第二重判断</div><div class=\"line\">\t\t\t\t&#123;</div><div class=\"line\">\t\t\t\t  System.out.println(&quot;第一次办理身份证&quot;);</div><div class=\"line\">\t\t\t\t  instance=new IdentityCardNo();</div><div class=\"line\">\t\t\t\t  instance.setIdentityCardNo(&quot;44060321938312121&quot;);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\telse</div><div class=\"line\">\t\t\t\t  System.out.println(&quot;重复办理身份证，获取旧号码&quot;);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\treturn instance;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tpublic void setIdentityCardNo(String no)&#123;</div><div class=\"line\">\t\tthis.no=no;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tpublic String getIdentityCardNo()&#123;</div><div class=\"line\">\t\treturn this.no;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">/*************************/</div><div class=\"line\">class Client </div><div class=\"line\">&#123;</div><div class=\"line\">  public static void main(String args[])</div><div class=\"line\">  &#123;</div><div class=\"line\">\tIdentityCardNo no1,no2;</div><div class=\"line\">\tno1=IdentityCardNo.getInstance();</div><div class=\"line\">\tno2=IdentityCardNo.getInstance();</div><div class=\"line\">\tSystem.out.println(&quot;身份证号码是否一致：&quot;+(no1==no2));</div><div class=\"line\">\t  </div><div class=\"line\">\tString str1,str2;</div><div class=\"line\">\tstr1=no1.getIdentityCardNo();</div><div class=\"line\">\tstr2=no2.getIdentityCardNo();</div><div class=\"line\">\tSystem.out.println(&quot;内容是否相等：&quot;+str1.equalsIgnoreCase(str2));</div><div class=\"line\">\tSystem.out.println(&quot;是否是相同对象：&quot;+(str1==str2));</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>从结果(都为true)可以看出，两次创建的 IdentityCardNo 对象内存地址相同，是同一个对象;<br>封装在其中的号码no属性不仅值相等，其内存地址也一致，是同一个成员属性。</p>\n</li>\n</ul>\n<p>【参考】(作者：刘伟 <a href=\"http://blog.csdn.net/lovelion\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/lovelion</a>)</p>\n"}
{"tags":[{"name":"面试","permalink":"http://yoursite.com/tags/面试/","url":"\\async\\tags\\面试.json","count":4}],"categories":[],"url":"\\async\\posts\\2017\\06\\17\\web前端问答汇总-综合类.json","date":1497682874000,"path":{"year":2017,"month":6,"day":17,"name":"web前端问答汇总-综合类"},"title":"web前端问答汇总--综合类","permalink":"http://yoursite.com/2017/06/17/web前端问答汇总-综合类/","content":"<p>整理汇总一下常见的一些web前端问答知识点<br>继续整理:<br><a href=\"http://www.ujiuye.com/jiuye/2016/1905_2.html\" target=\"_blank\" rel=\"external\">http://www.ujiuye.com/jiuye/2016/1905_2.html</a><br><a href=\"http://www.offcn.com/index.php?m=content&amp;c=tag&amp;a=lists&amp;tag=WEB%C7%B0%B6%CB%C3%E6%CA%D4%CC%E2\" target=\"_blank\" rel=\"external\">http://www.offcn.com/index.php?m=content&amp;c=tag&amp;a=lists&amp;tag=WEB%C7%B0%B6%CB%C3%E6%CA%D4%CC%E2</a></p>\n<hr>\n<h3 id=\"综合性\"><a href=\"#综合性\" class=\"headerlink\" title=\"综合性\"></a>综合性</h3><p><code>前端页面由哪三层构成，作用是什么?</code><br>结构层 Html 、表示层 CSS 、行为层 js<br>网页的结构层（structural layer）主要指DOM节点;即由 HTML 或 XHTML 之类的标记语言负责创建。标签，也就是那些出现在尖括号里的单词，对网页内容的语义含义做出了描述，但这些标签不包含任何关于如何显示有关内容的信息。例如，P 标签表达了这样一种语义：“这是一个文本段。”<br>网页的表示层（presentation layer）主要是指页面渲染，由 CSS 负责创建。 CSS 对“如何显示有关内容”的问题做出了回答。<br>网页的行为层（behavior layer）主要指页面动画效果，即“内容应该如何对事件做出反应”。这是 Javascript 语言和 DOM 主宰的领域。<br>网页的表示层和行为层总是存在的，即使我们未明确地给出任何具体的指令也是如此。此时， Web 浏览器将把它的默认样式和默认事件处理函数施加在网页的结构层上。例如，浏览器会在呈现“文本段”元素时留出页边距，有些浏览器会在用户把鼠标指针悬停在 某个元素的上方时弹出一个显示着该元素的 title 属性值的提示框，等等。</p>\n<p><code>一般用哪些流览器测试页面?这些浏览器的内核分别是什么?</code><br>IE: trident内核<br>Firefox火狐：gecko内核<br>Safari：webkit内核<br>Opera：以前是presto内核，Opera现已改用Google Chrome的Blink内核<br>Chrome谷歌：Blink(基于webkit，Google与Opera Software共同开发)</p>\n<p><code>浏览器兼容问题</code><br>css兼容性问题：<br>①不同浏览器的标签默认的外补丁和内补丁不同，解决方案：用通配符*来设置各个标签的内外补丁是0(即设置margin和padding为0);<br>②div的垂直居中问题 vertical-align：middle;文字居中：将行距增加到和整个div一样，高line-height=行高;<br>③margin加倍问题：设置为float的div在ie下的margin会加倍。解决方案：为这个div设置样式：display:inline;<br>js兼容性问题：<br>①在标准的事件绑定中绑定事件的方法函数为addEventListener，而IE使用的是attachEvent;<br>②事件处理中event属性的获取不同。标准浏览器是作为参数带入，然后通过e.target获取目标元素;而IE是通过window.event方式获得，通过e.srcElement获取目标元素;</p>\n<p><code>写出几种IE6 BUG的解决方法</code><br>1.双边距BUG float引起的 使用display<br>2.3像素问题 使用float引起的 使用dislpay:inline -3px<br>3.超链接hover 点击后失效 使用正确的书写顺序 link visited hover active<br>4.Ie z-index问题 给父级添加position:relative<br>5.Png 透明 使用js代码 改<br>6.Min-height 最小高度 ！Important 解决’<br>7.select 在ie6下遮盖 使用iframe嵌套<br>8.为什么没有办法定义1px左右的宽度容器（IE6默认的行高造成的，使用over:hidden,zoom:0.08 line-height:1px）</p>\n<p><code>如何对网站的文件和资源进行优化?期待的解决方案包括：</code><br>文件合并<br>文件最小化/文件压缩<br>使用CDN托管<br>缓存的使用</p>\n<p><code>简述同步和异步的区别</code><br>同步是阻塞模式，异步是非阻塞模式。<br>同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；<br>异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。</p>\n<p><code>什么叫优雅降级和渐进增强？</code><br>渐进增强 progressive enhancement：<br>针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。<br>优雅降级 graceful degradation：<br>一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。<br>区别：<br>a. 优雅降级是从复杂的现状开始，并试图减少用户体验的供给<br>b. 渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要<br>c. 降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带</p>\n<p><code>模块化编程</code><br>①AMD(异步模块定义) requirejs<br>defined(id,deps,factory)<br>require([dependency],function(){})<br>异步加载，浏览器不会失去响应<br>它指定的回调函数，只有前面的模块都加载完成后，才会运行，解决了依赖性问题<br>②CMD(通用模块定义) seajs<br>模块定义方式和模块加载时机处理不同<br>defined(id,deps,factory)<br>function(require,exports,module)<br>module.exports = <strong>__</strong>;<br>③区别：AMD依赖前置，在定义模块的时候就要声明其依赖的模块;CMD就近依赖，只有在用到哪个模块的时候再去require;</p>\n<p><code>一个页面从URL到加载显示完成，都发生了什么?</code><br>①通过DNS将该地址解析成IP地址;<br>②发起网络连接，进行http协议会话：客户端发送报头(请求报头)，服务端回馈报头(响应报头)<br>③返回一个页面(根据页面上的外链的URL重新发送请求获取)<br>④接收文件完毕，对加载到的资源进行语法解析，以及相应的内部数据结构(网页渲染)</p>\n<hr>\n<h3 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h3><p><code>一次完整的HTTP事务是怎样的一个过程？</code><br>基本流程：<br>a. 域名解析<br>b. 发起TCP的3次握手<br>c. 建立TCP连接后发起http请求<br>d. 服务器端响应http请求，浏览器得到html代码<br>e. 浏览器解析html代码，并请求html代码中的资源<br>f. 浏览器对页面进行渲染呈现给用户</p>\n<p><code>HTTP的状态码有哪些？</code></p>\n<p><code>HTTPS是如何实现加密？</code></p>\n<hr>\n<h3 id=\"算法相关\"><a href=\"#算法相关\" class=\"headerlink\" title=\"算法相关\"></a>算法相关</h3><p><code>队列、堆、栈的区别?</code><br>队列是先进先出：就像一条路，有一个入口和一个出口，先进去的就可以先出去。而栈就像一个箱子，后放的在上边，所以后进先出。堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。<br>栈(Stack)是操作系统在建立某个进程时或者线程为这个线程建立的存储区域。在编程中，例如C/C++中，所有的局部变量都是从栈中分配内存空间，实际上也不是什么分配，只是从栈顶向上用就行，在退出函数的时候，只是修改栈指针就可以把栈中的内容销毁，所以速度最快。<br>堆(Heap)是应用程序在运行的时候请求操作系统分配给自己内存，一般是申请/给予的过程。由于从操作系统管理的内存分配所以在分配和销毁时都要占用时间，所以用堆的效率低的多!但是堆的好处是可以做的很大，C/C++对分配的Heap是不初始化的。<br>在Java中除了简单类型(int,char等)都是在堆中分配内存，这也是程序慢的一个主要原因。但是跟C/C++不同，Java中分配Heap内存是自动初始化的。在Java中所有的对象(包括int的wrapper Integer)都是在堆中分配的，但是这个对象的引用却是在Stack中分配。也就是说在建立一个对象时从两个地方都分配内存，在Heap中分配的内存实际建立这个对象，而在Stack中分配的内存只是一个指向这个堆对象的指针(引用)而已。</p>\n<p><code>手写数组快速排序</code><br>关于快排算法的详细说明，可以参考阮一峰老师的文章快速排序<br>“快速排序”的思想很简单，整个排序过程只需要三步：<br>（1）在数据集之中，选择一个元素作为”基准”（pivot）。<br>（2）所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。<br>（3）对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。<br>参考代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">var quickSort = function(arr) </div><div class=\"line\">&#123; </div><div class=\"line\">   if (arr.length &lt;= 1) </div><div class=\"line\">   &#123; </div><div class=\"line\">      return arr; </div><div class=\"line\">   &#125; </div><div class=\"line\">   var pivotIndex = Math.floor(arr.length / 2); </div><div class=\"line\">   var pivot = arr.splice(pivotIndex, 1)[0]; </div><div class=\"line\">   var left = []; </div><div class=\"line\">   var right = []; </div><div class=\"line\">   for (var i = 0; i &lt; arr.length; i++)</div><div class=\"line\">   &#123; </div><div class=\"line\">      if (arr[i] &lt; pivot) </div><div class=\"line\">\t  &#123; </div><div class=\"line\">\t    left.push(arr[i]); </div><div class=\"line\">      &#125; </div><div class=\"line\">\t  else </div><div class=\"line\">\t  &#123; </div><div class=\"line\">\t    right.push(arr[i]); </div><div class=\"line\">\t  &#125; </div><div class=\"line\">   &#125; </div><div class=\"line\">   return quickSort(left).concat([pivot], quickSort(right)); </div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p><code>JavaScript实现二分法查找</code><br>二分法查找，也称折半查找，是一种在有序数组中查找特定元素的搜索算法。查找过程可以分为以下步骤：<br>（1）首先，从有序数组的中间的元素开始搜索，如果该元素正好是目标元素（即要查找的元素），则搜索过程结束，否则进行下一步。<br>（2）如果目标元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半区域查找，然后重复第一步的操作。<br>（3）如果某一步数组为空，则表示找不到目标元素。<br>参考代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 非递归算法 function binary_search(arr, key) </div><div class=\"line\">&#123; </div><div class=\"line\">  var </div><div class=\"line\">     low = 0, </div><div class=\"line\">\t high = arr.length - 1; </div><div class=\"line\">  while(low &lt;= high)</div><div class=\"line\">  &#123; </div><div class=\"line\">     var mid = parseInt((high + low) / 2); </div><div class=\"line\">\t if(key == arr[mid])</div><div class=\"line\">\t &#123; </div><div class=\"line\">\t   return mid; </div><div class=\"line\">\t &#125;</div><div class=\"line\">\t else if(key &gt; arr[mid])</div><div class=\"line\">\t &#123; </div><div class=\"line\">\t   low = mid + 1; </div><div class=\"line\">\t &#125;</div><div class=\"line\">\t else if(key &lt; arr[mid])</div><div class=\"line\">\t &#123; </div><div class=\"line\">\t   high = mid -1; </div><div class=\"line\">\t &#125;</div><div class=\"line\">\t else</div><div class=\"line\">\t &#123; </div><div class=\"line\">\t   return -1; </div><div class=\"line\">\t &#125; </div><div class=\"line\">  &#125; </div><div class=\"line\">&#125;; </div><div class=\"line\">var arr = [1,2,3,4,5,6,7,8,9,10,11,23,44,86]; </div><div class=\"line\">var result = binary_search(arr,10); </div><div class=\"line\">alert(result); // 9 返回目标元素的索引值</div><div class=\"line\"></div><div class=\"line\">// 递归算法 </div><div class=\"line\">function binary_search(arr,low, high, key) </div><div class=\"line\">&#123; </div><div class=\"line\">   if (low &gt; high)</div><div class=\"line\">   &#123; </div><div class=\"line\">      return -1; </div><div class=\"line\">   &#125; </div><div class=\"line\">   var mid = parseInt((high + low) / 2); </div><div class=\"line\">   if(arr[mid] == key)</div><div class=\"line\">   &#123; </div><div class=\"line\">     return mid; </div><div class=\"line\">   &#125;</div><div class=\"line\">   else if (arr[mid] &gt; key)</div><div class=\"line\">   &#123; </div><div class=\"line\">     high = mid - 1; </div><div class=\"line\">\t return binary_search(arr, low, high, key); </div><div class=\"line\">   &#125;</div><div class=\"line\">   else if (arr[mid] &lt; key)</div><div class=\"line\">   &#123; </div><div class=\"line\">     low = mid + 1; </div><div class=\"line\">\t return binary_search(arr, low, high, key); </div><div class=\"line\">   &#125; </div><div class=\"line\">&#125;; </div><div class=\"line\">var arr = [1,2,3,4,5,6,7,8,9,10,11,23,44,86]; </div><div class=\"line\">var result = binary_search(arr, 0, 13, 10); </div><div class=\"line\">alert(result); // 9 返回目标元素的索引值</div></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"Web安全\"><a href=\"#Web安全\" class=\"headerlink\" title=\"Web安全\"></a>Web安全</h3><p><code>你所了解到的Web攻击技术</code><br>（1）XSS（Cross-Site Scripting，跨站脚本攻击）：指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或者JavaScript进行的一种攻击。<br>（2）SQL注入攻击<br>（3）CSRF（Cross-Site Request Forgeries，跨站点请求伪造）：指攻击者通过设置好的陷阱，强制对已完成的认证用户进行非预期的个人信息或设定信息等某些状态更新。</p>\n<hr>\n<h3 id=\"前端性能\"><a href=\"#前端性能\" class=\"headerlink\" title=\"前端性能\"></a>前端性能</h3><p><code>前端性能优化</code><br>减少HTTP请求、使用内容发布网络、压缩组件、使用Expire头、JS放底部、CSS放顶部、避免CSS表达式等。</p>\n<p><code>如何优化图像、图像格式的区别？</code></p>\n<p><code>浏览器是如何渲染页面的？</code></p>\n<hr>\n<h3 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h3><p><code>对MVC、MVVM的理解</code><br>MVVM是Model-View-ViewModel的简写。<br>MVVM 是 Web 前端一种非常流行的开发模式，利用 MVVM 可以使我们的代码更专注于处理业务逻辑而不是去关心 DOM 操作。目前著名的 MVVM 框架有 vue, avalon, angular 等，这些框架各有千秋，但是实现的思想大致上是相同的：数据绑定 + 视图刷新。跟MVC一样，主要目的是分离视图(View)和模型(Model)。View可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。<br>在MVVM中，数据是核心，由于VIewModel与View之间的双向绑定，操作了ViewModel中的数据(当然只能是监控属性)，就会同步到DOM，我们透过DOM事件监控用户对DOM的改动，也会同步到ViewModel。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Rank: &#123;&#123;item.rank&#125;&#125;</div><div class=\"line\">var element = document.querySelector(&apos;#mobile-list&apos;);</div><div class=\"line\">var vm = new MVVM(element, &#123;</div><div class=\"line\">  &apos;title&apos; : &apos;Mobile List&apos;,</div><div class=\"line\">  &apos;showRank&apos;: true,</div><div class=\"line\">  &apos;brands&apos; : [</div><div class=\"line\">    &#123;&apos;name&apos;: &apos;Apple&apos;, &apos;rank&apos;: 1&#125;,</div><div class=\"line\">\t&#123;&apos;name&apos;: &apos;Galaxy&apos;, &apos;rank&apos;: 2&#125;,</div><div class=\"line\">\t&#123;&apos;name&apos;: &apos;OPPO&apos;, &apos;rank&apos;: 3&#125;</div><div class=\"line\">  ]</div><div class=\"line\">&#125;);</div><div class=\"line\">vm.set(&apos;title&apos;, &apos;Top 3 Mobile Rank List&apos;); // =&gt;Top 3 Mobile Rank List</div></pre></td></tr></table></figure></p>\n<p>以上这段如此简洁的代码，就是MVVM框架的一个简单的实现效果。在HTML代码里面，可能会嵌入很多自定义的属性(标记)，以此来实现数据的绑定，而且还可以进行一些简单的逻辑处理，比如if和循环等。<br>react应该也算是MVVM框架，但是与传统的MVVN框架不同的是，react默认数据绑定方式是单向绑定，而vue及angular都是双向绑定;react使用虚拟DOM配合JSX，而vue及angular直接将数据通过属性绑定在真实DOM上的。</p>\n<p><code>MVVM框架的优点：</code><br>1、方便测试<br>在MVC下，Controller基本是无法测试的，里面混杂了个各种逻辑，而且分散在不同的地方。有了MVVM我们就可以测试里面的viewModel，来验证我们的处理结果对不对。<br>2、便于代码的移植<br>可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。比如iOS里面有iPhone版本和iPad版本，除了交互展示不一样外，业务逻辑的model是一致的。这样，我们就可以以很小的代价去开发另一个app。<br>3、独立开发<br>开发人员可以专注于业务逻辑和数据的开发(ViewModel)，设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xml代码。</p>\n<hr>\n<h3 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h3><p><code>写一个function，清除字符串前后的空格。（兼容所有浏览器）</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function trim(str) </div><div class=\"line\">&#123;</div><div class=\"line\">   if (str &amp;&amp; typeof str === &quot;string&quot;) </div><div class=\"line\">   &#123;</div><div class=\"line\">\t return str.replace(/(^\\s*)|(\\s*)$/g,&quot;&quot;); //去除前后空白符</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>使用正则表达式验证邮箱格式</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var reg = /^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w&#123;2,3&#125;)&#123;1,3&#125;)$/; </div><div class=\"line\">var email = &quot;example@qq.com&quot;; </div><div class=\"line\">console.log(reg.test(email)); // true</div></pre></td></tr></table></figure></p>\n<hr>\n<p>参考出处：<a href=\"http://www.offcn.com/it/\" target=\"_blank\" rel=\"external\">http://www.offcn.com/it/</a></p>\n"}
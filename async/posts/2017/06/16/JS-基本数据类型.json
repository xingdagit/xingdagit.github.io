{"tags":[{"name":"JS","permalink":"http://yoursite.com/tags/JS/","url":"\\async\\tags\\JS.json","count":14}],"categories":[],"url":"\\async\\posts\\2017\\06\\16\\JS-基本数据类型.json","date":1497600219000,"path":{"year":2017,"month":6,"day":16,"name":"JS-基本数据类型"},"title":"JS-基本数据类型","permalink":"http://yoursite.com/2017/06/16/JS-基本数据类型/","content":"<h3 id=\"javascript基本数据类型\"><a href=\"#javascript基本数据类型\" class=\"headerlink\" title=\"javascript基本数据类型\"></a>javascript基本数据类型</h3><p>javascript拥有5种基本数据类型：<code>Number、String、Boolean、Undefined和Null</code></p>\n<ol>\n<li>基本类型值是指简单的数据段，都是<code>按值访问</code>的，因为可以操作保存在变量中的实际值;</li>\n<li>基本类型的值在内存中占据固定大小的空间，被保存在<code>栈内存</code>中。<br>一个变量向另一个变量复制基本类型的值时，会创建这个值的一个<code>副本</code>。</li>\n<li>不能给基本类型的值<code>添加属性</code>。</li>\n<li>用<code>typeof方法</code>可以确定一个值是哪种基本类型。</li>\n</ol>\n<h3 id=\"一、Number\"><a href=\"#一、Number\" class=\"headerlink\" title=\"一、Number\"></a>一、Number</h3><ul>\n<li>Number类型使用IEEE754格式来表示整数和浮点数值。<br>即不区分整数和浮点数，统一用Number表示。</li>\n<li>可以用一个值<code>减0</code>来将其转换成一个数字</li>\n<li><p>三种字面量格式是十进制、八进制、十六进制</p>\n<ol>\n<li>八进制字面值的第一位必须是0，然后是八进制数字序列(0-7),如果字面值中的数值超出了范围，那么前导0将被忽略，后面的数值被当作十进制数解析。<br>八进制字面量在严格模式下是无效的，会导致js抛出错误。</li>\n<li>十六进制字面值的前两位必须是0x,后跟十六进制数字序列，字母可大写可小写。<br>十六进制中字面值中的数值走出范围，如出现g,h等会报错。</li>\n<li>在进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值</li>\n</ol>\n</li>\n<li><p>数值表示</p>\n<ol>\n<li>js中可以保存正0和负0，且被认为相等</li>\n<li>浮点数值：<br>1)该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字<br>2)由于浮点型数值需要的内存空间是保存整数值的两倍，因此js会不失时机地将浮点数值转换成整数值，若小数点后没有跟任何数字或者浮点值本身表示的就是一个整数，这个数值会作为整数值来保存。<br>3)浮点数值的最高精度是17位小数<br>4)对于极大或者极小的数，可以用科学计数法e来表示的浮点数值来表示<br>5)默认情况下，js会将小数点后面带有6个0以上的浮点数值转换为以e表示法表示的数值<br>6)基于IEEE754数值的浮点计算的通病是舍入误差的问题。如：0.1+0.2 === 0.3(15个0)4</li>\n</ol>\n</li>\n<li><p>js中的数值范围</p>\n<ol>\n<li>js中的数值范围是<code>Number.MIN_VALUE(5e-324)</code> ―― <code>Number.MAX_VALUE(1.7976931348623157e+308)</code></li>\n<li>如果超出正数范围，输出Infinity(正无穷大)，<br>如果超出负数范围，输出-Infinity(负无穷大)，<br>且两者都不能参与数值计算。</li>\n<li>Number.MAX_VALUE+1 != Infinity,因为计算机最多保存52位尾数位，保存不了1000多位，早就失去精度，<br>即小数位全为0，所以相加不变。</li>\n<li>Number.MIN_VALUE - 1 != -Infinity,也是同样的原因，所以结果为-1</li>\n<li>可以用<code>isFinite()</code>来确定一个数值是不是有穷的,包含着隐式类型转换<code>Number()</code><br>如：<code>isFinite(NaN)</code>//false</li>\n</ol>\n</li>\n<li><p>NaN</p>\n<ol>\n<li>NaN与任何值都不相等，包括NaN本身</li>\n<li>任何涉及NaN的操作都会返回NaN</li>\n<li><code>isNaN()</code>来判断这个数字是不是NaN,包含着隐式类型转换Number()</li>\n</ol>\n</li>\n<li><p>数值转换<br>有三种方法：<code>Number()、parseInt()和parseFloat()</code>。<br>三种方法可以接受各种进制的数字，但对于含数字的字符串并不适用。<br>若数字为1.2. 会报错，但字符串为’1.2.’则不会报错。</p>\n<ol>\n<li>Number()<br>可用于任何类型；<br><code>Number(true):1 || Number(false):0</code>;<br><code>Number(各种进制的数字)</code>：运算后的十进制的数字，如1.0或1.或01会以1输出;<br><code>Number(undefined)</code>:NaN;<br><code>Number(null)</code>:0;<br><code>Number(字符串)</code>：<br>   字符串中不识别八进制，按照十进制数字处理<br>   1)Number(只包含数字的十进制和十六进制的字符串)：运算后的十进制的数字<br>   2)Number(‘’和’ ‘):0<br>   3)Number(其他情况的字符串):NaN<br><code>Number(对象)</code>：<br>   1)Number([]和[0]和[-0]):0<br>   2)Number([数字])：运算后的数字<br>   3)Number([1,2]和{}和其他对象):NaN</li>\n<li>parseInt()<br>用于把字符串转换成数值。<br>在转换字符串时，会忽略字符串前面的空格，直到找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt()就会返回NaN。如果是，则继续解析，直到解析完成或者遇到非数字字符。<br>可以识别出各种进制的整数，但对于八进制字面量的字符串，ECMAScript3会解析而ECMAScript5不会解析<br>提供第二个参数，表示多少进制，如：<code>parseInt(&#39;123&#39;,16或10或2)</code><br><code>parseInt(各种进制的数字)</code>：运算后的十进制的数字。如1.0或1.或01会以1输出<br>因为parseInt()是专门用来处理字符串转换数字的，所以<code>parseInt(其他类型包括&#39;&#39;)</code>//NaN</li>\n<li>parseFloat<br>用于把字符串转换成数值。<br>类似于parseInt()，会忽略字符串前面的空格，直到找到第一个非空格字符。<br><code>parseFloat()</code>只能解析十进制字符串<br><code>parseFloat(各种进制的数字)</code>：运算后的十进制的数字。如1.0或1.或01会以1输出</li>\n</ol>\n</li>\n<li><p>合法的Number类型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">123;   // 整数123 (由于计算机使用二进制，所以有时候用十六进制表示整数比较方便)</div><div class=\"line\">0.456; // 浮点数0.456</div><div class=\"line\">1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5</div><div class=\"line\">-99;   // 负数</div><div class=\"line\">NaN;   // NaN表示Not a Number，当无法计算结果时用NaN表示</div><div class=\"line\">Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity</div></pre></td></tr></table></figure>\n</li>\n<li><p>Number可以直接做四则运算，规则和数学一致<br><code>2 / 0;</code>// Infinity<br><code>0 / 0;</code>// NaN </p>\n</li>\n</ul>\n<h3 id=\"二、String-字符串\"><a href=\"#二、String-字符串\" class=\"headerlink\" title=\"二、String(字符串)\"></a>二、String(字符串)</h3><ul>\n<li>以单引号<code>&#39;</code> 或 双引号<code>&quot;</code> 括起来的任意字符序列(内容本身包含时则使用转义字符\\来标识)</li>\n<li>比如’abc’，”xyz”，’I\\’m \\”OK\\”!’</li>\n<li>多行字符串：用反引号 <code>\\</code> 作换行处理<br>如：<br>“这是一个\\<br> 多行\\<br> 字符串”</li>\n<li><p>ECMAScript中的字符串是不可变的。</p>\n</li>\n<li><p>字符串转换</p>\n<ol>\n<li>toString()<br>Null和Undefined<code>没有</code>该方法（可以用String()方法）<br>Boolean、Object、String<code>有</code>该方法<br>Number使用该方法可以传递基数2、8、10、16<br>如<code>var num = 10;num.toString(2);</code>//1010 。但10.toString(2)会报错,因为数字后面不能跟标识符</li>\n<li>要把某个值转换为字符串，也可以使用<code>加号操作符</code>把它与一个空字符串’’加在一起</li>\n<li>如果数组中的某一项的值是null或者undefined，<br>那么该值在join()、toLocaleString()、toString()和valueOf()方法返回的结果中以空字符串表示</li>\n</ol>\n</li>\n<li><p>连接字符串:<br>1）用<code>+</code>号连接：<code>var message = &#39;你好, &#39; + name + &#39;, 你今年&#39; + age + &#39;岁了!&#39;;</code><br>2）模板字符串(要用单引号)：<code>var message = &#39;你好, ${name}, 你今年${age}岁了!&#39;;</code><br>字符串连接需要先创建一个新字符串，然后在新字符串中填充两个需要拼接的字符串，最后再销毁原来的字符串。这个过程在后台发生，也是在某些旧版本浏览器(IE6)拼接字符串速度慢的原因，但后来已经解决了这个低效率问题</p>\n</li>\n<li><p>字符串长度：<code>str.length</code>;</p>\n</li>\n<li><p>获取字符串某个指定位置的字符：<br><code>str[下标];</code>//从0开始，超出范围返回undefined不报错<br>（字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但也没有任何效果）</p>\n</li>\n<li><p>一些字符串操作方法：<br>调用这些方法本身<code>不会改变</code>原有字符串的内容，而是<code>返回一个新字符串</code><br>1)<code>对象.toUpperCase();</code>//将字符串转化成大写<br>2)<code>对象.toLowerCase();</code>//将字符串转化成小写<br>3)<code>对象.charAt(index);</code>//返回指定位置的字符(index：0~length-1，不在返回空字符串)(其实也可以用数组形式实现相同效果)<br>4)<code>对象.indexOf(需检索的字符串值,[开始检索位置]);</code>//返回某个指定的字符串值在字符串中首次出现的位置，没有返回-1<br>5)<code>对象.split(切割标志,[切割后元素数]);</code> //将字符串分割为字符串数组，并返回此数组<br>6)<code>对象.substring(开始位置,[结束位置]);</code> //提取字符串中介于[开始位置,结束位置-1)的字符<br>7)<code>对象.substr(开始位置,[提取字符串的长度])</code>;// 从字符串中提取从开始位置起的指定数目(长度)的字符串(开始位置为负时表示从尾开始)</p>\n</li>\n</ul>\n<h3 id=\"三、Boolean-布尔值\"><a href=\"#三、Boolean-布尔值\" class=\"headerlink\" title=\"三、Boolean(布尔值)\"></a>三、Boolean(布尔值)</h3><pre><code>* 值：true、false、布尔运算计算值(2 &gt; 1; // 这是一个true值)\n* 出现场景：\n  1. 条件语句导致系统执行的隐士类型转换\n  2. 字面量或变量定义\n* 类型转换 \n  1. Number(true): 1 || Number(false) : 0 \n  2. String(true):&apos;true&apos; || String(false):&apos;false&apos;\n* Boolean()方法\n  1. Boolean(undefined):false\n  2. Boolean(null):false\n  3. Boolean(非空对象包括空数组[]和空对象{}):true\n  4. Boolean(非0): true || Boolean(0和NaN):false\n  5. Boolean(非空包括空格字符串):true || Boolean(&apos;&apos;):false\n* 注意：true不一定等于1,false也不一定等于0\n</code></pre><h3 id=\"四、Undefined\"><a href=\"#四、Undefined\" class=\"headerlink\" title=\"四、Undefined\"></a>四、Undefined</h3><pre><code>* Undefined类型只有一个值，就是undefined。\n* undefined 表示一个未声明的变量，或已声明但没有赋值的变量，或一个并不存在的对象属性。\n* `var a `&lt;=&gt; `var a = undefined;`\n* 对于尚未声明过的变量，只能执行一项操作，就是使用`typeof操作符`检测其数据类型【但在严格模式下会导致错误】\n* 出现场景：\n  1. 已声明未赋值的变量\n  2. 获取对象不存在的属性\n  3. 无返回值的函数的执行结果\n  4. 函数的参数没有传入(可用于判断函数参数是否传递成功)\n  5. `void(expression)`\n* 类型转换\n  1. Boolean(undefined)：false \n  2. Number(undefined):NaN \n  3. String(undefined):&apos;undefined&apos;\n* 注意：只能用`===`运算来测试某个值是否是未定义的，因为`==`运算符认为undefined值等价于 null。\n</code></pre><h3 id=\"五、Null\"><a href=\"#五、Null\" class=\"headerlink\" title=\"五、Null\"></a>五、Null</h3><pre><code>* Null类型只有一个值---`null`,逻辑角度看，null值表示一个空对象指针\n* null表示一个“空”（没有值）。它和0(数值)以及空字符串`&apos;&apos;`(长度为0的字符串)不同。\n* 如果定义的变量将用于保存对象，最好将该变量初始化为null。\n* 实际上`undefined`值是派生自`null值`的，所以`undefined == null`(但===不成立)\n* 出现场景：对象不存在时\n* 类型转换：\n  1. Boolean(null)：false\n  2. Number(null):0\n  3. String(null):&apos;null&apos;\n* 注意1：null是空对象指针，而[]是空数组，{}是空对象，三者不相同。\n* 注意2：null不能添加自定义属性\n* 其他语言中也有类似JavaScript的null的表示：Java也用null，Swift用nil，Python用None表示。\n</code></pre>"}
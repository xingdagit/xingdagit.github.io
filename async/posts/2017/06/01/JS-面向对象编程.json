{"tags":[],"categories":[],"url":"\\async\\posts\\2017\\06\\01\\JS-面向对象编程.json","date":1496326905000,"path":{"year":2017,"month":6,"day":1,"name":"JS-面向对象编程"},"title":"JS-面向对象编程","permalink":"http://yoursite.com/2017/06/01/JS-面向对象编程/","content":"<ul>\n<li>一般面向对象的两个基本概念：类：类是对象的类型模板，表示抽象；实例：实例是根据类创建的对象，表示具体实例。但在JavaScript中，JavaScript不区分类和实例的概念，而是通过<code>原型（prototype）</code>来实现面向对象编程</li>\n<li><p>原型是指当我们想要创建xiaoming这个具体的学生时，并没有一个Student类型可用。而使用一个现成的对象来创建：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">//先创建一个student的对象</div><div class=\"line\">var Student = &#123;</div><div class=\"line\">    name: &apos;Robot&apos;,</div><div class=\"line\">    height: 1.2,</div><div class=\"line\">    run: function () &#123;</div><div class=\"line\">        console.log(this.name + &apos; is running...&apos;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">//然后创建出xiaoming对象</div><div class=\"line\">var xiaoming = &#123;</div><div class=\"line\">    name: &apos;小明&apos;</div><div class=\"line\">&#125;;</div><div class=\"line\">//把xiaoming的原型指向了对象Student，看上去xiaoming仿佛是从Student继承下来的</div><div class=\"line\">xiaoming.__proto__ = Student ;</div><div class=\"line\">//此时xiaoming不仅可以调用已定义的name属性，也可以调用没有定义run()方法。因为run()方法是从Student继承而来</div></pre></td></tr></table></figure>\n</li>\n<li><p><img src=\"http://www.liaoxuefeng.com/files/attachments/001435287613668a73ab76ccc85411282c1b1370be41636000/l\" alt=\"原型图解\"></p>\n</li>\n<li><p><code>JavaScript的原型链</code>和<code>Java的Class</code>区别就在于它没有“Class”的概念，所有对象都是实例。继承关系不过是把一个对象的原型指向另一个对象而已;</p>\n</li>\n<li>如果把xiaoming的原型指向其他无run()方法的对象，则无法调用run()方法了：<code>xiaoming.__proto__ = Bird;</code></li>\n</ul>\n<p>注意：上述代码仅用于演示目的。在编写JavaScript代码时，不要直接用<code>obj.__proto__</code>去改变一个对象的原型。</p>\n<ul>\n<li>一般通过编写一个函数来创建对象：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 原型对象:</div><div class=\"line\">var Student = &#123;</div><div class=\"line\">    name: &apos;Robot&apos;,</div><div class=\"line\">    height: 1.2,</div><div class=\"line\">    run: function () &#123;</div><div class=\"line\">        console.log(this.name + &apos; is running...&apos;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">function createStudent(name) &#123;</div><div class=\"line\">    var s = Object.create(Student); // 基于Student原型创建一个新对象:</div><div class=\"line\">    s.name = name; // 初始化新对象:</div><div class=\"line\">    return s;</div><div class=\"line\">&#125;</div><div class=\"line\">var xiaoming = createStudent(&apos;小明&apos;);</div><div class=\"line\">xiaoming.run(); // 小明 is running...</div><div class=\"line\">xiaoming.__proto__ === Student; // true</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"1-创建对象\"><a href=\"#1-创建对象\" class=\"headerlink\" title=\"1.创建对象\"></a>1.创建对象</h3><ul>\n<li>JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。</li>\n<li>当用<code>obj.xxx</code>访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如没找到，就到其原型对象上找，如还没找到，就一直上溯到Object.prototype对象，如最后还没找到就只能返回undefined。</li>\n<li><p>举例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var arr = [1, 2, 3]; //创建一个Array对象</div><div class=\"line\">// 其原型链是：</div><div class=\"line\">arr ----&gt; Array.prototype ----&gt; Object.prototype ----&gt; null</div><div class=\"line\">//所有的Array对象上都可以调用Array.prototype定义的indexOf()、shift()等方法</div><div class=\"line\">/*********************************************************************/</div><div class=\"line\">function foo() &#123;  return 0;  &#125;  //创建一个函数</div><div class=\"line\">//函数也是一个对象，它的原型链是：</div><div class=\"line\">foo ----&gt; Function.prototype ----&gt; Object.prototype ----&gt; null</div><div class=\"line\">//所有函数都可以调用Function.prototype定义的apply()方法</div></pre></td></tr></table></figure>\n</li>\n<li><p>如果原型链很长，那么访问一个对象的属性就会因为花更多的时间查找而变得更慢，因此要注意不要把原型链搞得太长。</p>\n</li>\n</ul>\n<h3 id=\"2-构造函数\"><a href=\"#2-构造函数\" class=\"headerlink\" title=\"2.构造函数\"></a>2.构造函数</h3><ul>\n<li>除了直接用<code>{ ... }</code>创建一个对象外，JavaScript还可用一种构造函数的方法来创建对象。</li>\n<li><p>步骤：<br>1)先定义一个构造函数：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Student(name) &#123;</div><div class=\"line\">    this.name = name;</div><div class=\"line\">    this.hello = function () &#123;</div><div class=\"line\">        alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 2)用关键字new来调用这个函数，并返回一个对象(构造函数)：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var xiaoming = new Student(&apos;小明&apos;);  //使用构造函数(如不写new则为普通函数，返回undefined)</div><div class=\"line\">xiaoming.name; // &apos;小明&apos;</div><div class=\"line\">xiaoming.hello(); // Hello, 小明!</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>构造函数绑定的this指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this;</li>\n<li>新创建的xiaoming的原型链是：<br>  <code>xiaoming ----&gt; Student.prototype ----&gt; Object.prototype ----&gt; null</code> //xiaoming的原型指向函数Student的原型</li>\n<li><p>如果又创建了xiaohong、xiaojun，那么这些对象的原型与xiaoming是一样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">xiaoming ↘</div><div class=\"line\">xiaohong -→ Student.prototype ----&gt; Object.prototype ----&gt; null</div><div class=\"line\">xiaojun  ↗</div></pre></td></tr></table></figure>\n</li>\n<li><p>用构造函数创建的对象还从原型上获得了一个constructor属性，它指向其原型对象本身：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//用new Student()创建的对象从原型上获得constructor属性，它指向函数Student本身</div><div class=\"line\">xiaoming.constructor === Student.prototype.constructor; // true</div><div class=\"line\">Student.prototype.constructor === Student; // true</div><div class=\"line\">Object.getPrototypeOf(xiaoming) === Student.prototype; // true</div><div class=\"line\">xiaoming instanceof Student; // true</div></pre></td></tr></table></figure>\n</li>\n<li><p><img src=\"http://www.liaoxuefeng.com/files/attachments/00143529922671163eebb527bc14547ac11363bf186557d000/l\" alt=\"图解\"></p>\n</li>\n<li>红色箭头是原型链。</li>\n<li><code>Student.prototype</code>指向的对象就是<code>xiaoming</code>和<code>xiaohong的原型对象</code>，这个原型对象自己还有个属性<code>constructor</code>，指向<code>Student函数</code>本身，而<code>函数Student</code>也有个属性<code>prototype</code>指<code>向xiaoming</code>、<code>xiaohong的原型对象</code>。</li>\n<li>结论：xiaoming、xiaohong对象“继承”自Student</li>\n<li>一个需注意的问题：通过<code>new Student()</code>创建的对象，他们的属性都是不同的，尽管代码相同。但如hello的一些函数因为代码都是一样，实际上只需共享同一个函数即可，这样可节省很多内存。</li>\n<li>要让创建的对象共享一个hello函数，根据对象的属性查找原则，我们只要把hello函数移动到xiaoming、xiaohong这些对象共同的原型<code>Student.prototype</code>上就可以了。</li>\n<li><p>修改代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Student(name) &#123;</div><div class=\"line\">    this.name = name;</div><div class=\"line\">&#125;</div><div class=\"line\">Student.prototype.hello = function () &#123;</div><div class=\"line\">  alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p>注意：调用构造函数千万不要忘记写<code>new</code>。为区分普通函数和构造函数，构造函数首字母应当大写，而普通函数首字母应当小写，这样一些语法检查工具如jslint将可以帮你检测到漏写的new。</p>\n</li>\n<li>还可以通过自定义一个<code>内部封装所有的new操作的构造函数</code>来创建对象：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Student(props) &#123;</div><div class=\"line\">  this.name = props.name || &apos;匿名&apos;;  // 默认值为&apos;匿名&apos;</div><div class=\"line\">  this.grade = props.grade || 1;      // 默认值为1</div><div class=\"line\">&#125;</div><div class=\"line\">Student.prototype.hello = function () &#123;</div><div class=\"line\">  alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);</div><div class=\"line\">&#125;;</div><div class=\"line\">function createStudent(props) &#123;</div><div class=\"line\">  return new Student(props || &#123;&#125; )</div><div class=\"line\">&#125;</div><div class=\"line\">//这种createStudent()函数的优点：一、不需要new来调用，二、参数非常灵活(可以传也可以不传)</div><div class=\"line\">//如果创建的对象有很多属性，我们只需要传递需要的某些属性，剩下的属性可以用默认值。</div><div class=\"line\">//由于参数是一个Object，我们也无需记忆参数的顺序。</div><div class=\"line\">//如果恰好从JSON拿到了一个对象，就可以直接创建出xiaoming</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"3-原型继承\"><a href=\"#3-原型继承\" class=\"headerlink\" title=\"3.原型继承\"></a>3.原型继承</h3><ul>\n<li>一般语言的继承实际上是类型的扩展。但JavaScript由于采用原型继承，无法直接扩展一个类Class（何况根本不存在Class这种类型）</li>\n<li>JavaScript也有它的原型继承方式：<br>1)定义新的构造函数，并在内部用call()调用希望“继承”的构造函数，并绑定this；<br>2)借助中间函数F()实现原型链继承，最好通过封装的inherits函数完成；<br>3)继续在新的构造函数的原型上定义新方法。</li>\n<li><a href=\"http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014344997013405abfb7f0e1904a04ba6898a384b1e925000\" target=\"_blank\" rel=\"external\">具体实现</a></li>\n</ul>\n<h3 id=\"4-class继承\"><a href=\"#4-class继承\" class=\"headerlink\" title=\"4.class继承\"></a>4.class继承</h3><ul>\n<li>JavaScript的对象模型是基于原型实现的，特点是简单，缺点是理解起来比传统的类－实例模型要困难，最大的缺点是继承的实现需要编写大量代码，并且需要正确实现原型链。</li>\n<li>JavaScript从ES6开始正式引入了新的关键字class（目的就是让定义类更简单）</li>\n<li><p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">//用新的class关键字来编写Student（不需function关键字）</div><div class=\"line\">class Student &#123;</div><div class=\"line\">    constructor(name) &#123;   //定义了构造函数constructor</div><div class=\"line\">        this.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\">    hello() &#123;             //定义了本来定义在原型对象上的函数hello()</div><div class=\"line\">        alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">//最后，创建一个Student对象代码和前面完全一样：</div><div class=\"line\">var xiaoming = new Student(&apos;小明&apos;);</div><div class=\"line\">xiaoming.hello();</div></pre></td></tr></table></figure>\n</li>\n<li><p>用class定义对象的另一个好处是继承更方便了：这种方式可忽略原型继承的中间对象，原型对象的构造函数等，直接通过<code>extends</code>来实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">class PrimaryStudent extends Student  //表示原型链对象来自Student</div><div class=\"line\">&#123;</div><div class=\"line\">    constructor(name, grade) &#123;</div><div class=\"line\">        super(name);  //记得用super调用父类的构造方法(否则父类的name属性无法正常初始化)</div><div class=\"line\">        this.grade = grade;</div><div class=\"line\">    &#125;</div><div class=\"line\">    myGrade() &#123;</div><div class=\"line\">        alert(&apos;I am at grade &apos; + this.grade);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; </div><div class=\"line\">// PrimaryStudent已经自动获得了父类Student的hello方法，我们又在子类中定义了新的myGrade方法</div></pre></td></tr></table></figure>\n</li>\n<li><p>class的作用其实就是让JavaScript引擎去实现原来需要我们自己编写的原型链代码(极大地简化了原型链代码)</p>\n</li>\n<li>因不是所有的主流浏览器都支持ES6的class。如果要用就需要一个工具把class代码转换为传统的prototype代码，可以试试Babel这个工具</li>\n</ul>\n"}
{"tags":[{"name":"JS","permalink":"http://yoursite.com/tags/JS/","url":"\\async\\tags\\JS.json","count":15}],"categories":[],"url":"\\async\\posts\\2017\\06\\01\\JS-函数.json","date":1496314261000,"path":{"year":2017,"month":6,"day":1,"name":"JS-函数"},"title":"JS-函数","permalink":"http://yoursite.com/2017/06/01/JS-函数/","content":"<h2 id=\"一、函数定义和调用\"><a href=\"#一、函数定义和调用\" class=\"headerlink\" title=\"一、函数定义和调用\"></a>一、函数定义和调用</h2><ol>\n<li>定义函数：<br><code>function 函数名(参数) {…}</code><br>JavaScript的函数也是一个对象，函数名可视为指向该函数的变量，因此也可以这样定义函数：<br><code>var abs = function (x) {..};</code></li>\n<li>调用函数：<br>1)在<code>&lt;script&gt;</code>标签内调用：<code>函数名(参数);</code><br>2)在HTML文件中调用，如通过点击按钮后调用已定义好的函数：<code>onclick=&quot;函数名(参数)&quot;</code><br>JavaScript允许传入任意个参数而不影响调用（过多忽略,过少即传入undefined）</li>\n<li>一旦执行到<code>return</code>时，函数就执行完毕，并将结果返回；<br>如果没有return语句，函数执行完毕后也会返回结果，只是结果为<code>undefined</code></li>\n<li><p>关键字<code>arguments</code></p>\n<ul>\n<li>只在函数内部起作用</li>\n<li>利用arguments，可获得当前函数调用者传入的<code>所有参数</code></li>\n<li>即使函数不定义任何参数，还是可以拿到参数的值</li>\n<li><p>语法类似<code>Array</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo(x) </div><div class=\"line\">&#123; </div><div class=\"line\">   alert(x); // 10 </div><div class=\"line\">for (var i=0; i&lt;arguments.length; i++) </div><div class=\"line\">&#123; </div><div class=\"line\">   alert(arguments[i]); // 10, 20, 30 </div><div class=\"line\">&#125; </div><div class=\"line\">&#125; </div><div class=\"line\">foo(10, 20, 30);</div></pre></td></tr></table></figure>\n</li>\n<li><p>最常用于判断传入参数的个数：<code>arguments.length;</code></p>\n</li>\n<li>可用于把中间某参数变为“可选”参数，<br>方法：通过arguments.length判断个数，然后重新调整参数并赋值</li>\n</ul>\n</li>\n<li><code>rest参数</code><ul>\n<li>ES6标准引入</li>\n<li>rest参数只能<code>写在最后</code>，前面用…标识</li>\n<li>变量rest用于以<code>数组形式</code>接收<code>除已赋值给形参后剩余的参数</code>(没有写出的形参)（所以不需arguments也可获取了全部参数）</li>\n<li>如果传入的参数连正常定义的参数都没填满，rest参数会接收一个<code>空数组</code>（注意不是undefined）</li>\n</ul>\n</li>\n<li><code>注意return语句：JavaScript引擎有一个在行末自动添加分号的机制，所以注意return与后面返回的东西不要隔行</code></li>\n</ol>\n<h2 id=\"二、变量作用域\"><a href=\"#二、变量作用域\" class=\"headerlink\" title=\"二、变量作用域\"></a>二、变量作用域</h2><ol>\n<li>在JavaScript中，用var申明的变量实际上是有作用域的</li>\n<li><p>变量提升</p>\n<ul>\n<li>JavaScript的函数定义有个特点：先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部</li>\n<li><p>实例: JavaScript引擎自动提升了变量y的声明，但不会提升变量y的赋值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">   &apos;use strict&apos;;</div><div class=\"line\">   function foo() </div><div class=\"line\">&#123;</div><div class=\"line\">      var x = &apos;Hello, &apos; + y;  //虽是strict模式，但并不报错，原因是变量y在稍后申明了</div><div class=\"line\">      alert(x);    //显示Hello, undefined，说明变量y的值为undefined</div><div class=\"line\">      var y = &apos;aaa&apos;;</div><div class=\"line\">   &#125;</div><div class=\"line\">   foo();</div></pre></td></tr></table></figure>\n</li>\n<li><p>由于这一“特性”，在函数内部定义变量时要严格遵守<code>“在函数内部首先申明所有变量”</code>这一规则。</p>\n</li>\n<li>最常见的做法是<code>用一个var申明函数内部用到的所有变量</code>：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">   function foo() </div><div class=\"line\">&#123;</div><div class=\"line\">     var</div><div class=\"line\">         x = 1,      // x初始化为1</div><div class=\"line\">         y = x + 1,   // y初始化为2</div><div class=\"line\">         z, i;       // z和i为undefined</div><div class=\"line\">         …        // 其他语句:</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>全局作用域</p>\n<ul>\n<li>不在任何函数内定义的变量就具有全局作用域；</li>\n<li>JavaScript默认有一个全局对象<code>window</code>，全局作用域的变量实际上被<code>绑定</code>到window的一个属性<br>(调用：<code>window.全局变量名/全局变量名</code>)；</li>\n<li>以变量方式<code>var foo = function(){}</code>定义的函数实际上也是一个全局变量。<br>所以顶层函数的定义也被视为一个全局变量，并绑定到window对象(调用：<code>window.foo()/foo()</code>)；</li>\n<li>不同的JavaScript文件如使用了<code>相同</code>的全局变量，或者定义了<code>相同名字</code>的顶层函数，都会造成命名冲突；</li>\n<li>全局作用域<code>只有一个</code>，任何变量（函数也视为变量），如没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报<code>ReferenceError错误</code>；</li>\n<li>减少冲突的一个方法是把自己的所有变量和函数全部绑定到<code>一个全局变量</code>中。例如：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var ME = &#123;&#125;;// 唯一的全局变量ME</div><div class=\"line\">// 其他变量:</div><div class=\"line\">ME.name = &apos;TONY&apos;;</div><div class=\"line\">ME.num = 001;</div><div class=\"line\">// 其他函数:</div><div class=\"line\">ME.foo = function () &#123; … &#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>局部作用域</p>\n<ul>\n<li>JavaScript的变量作用域是函数内部,即局部作用域。</li>\n<li>函数体内部申明的变量的作用域为整个函数体,有局部作用域。<br>所以不同函数内部的同名变量互相独立；</li>\n<li>对于嵌套的函数，内部函数可访问外部函数定义的变量，反过来则不行；<br>若变量是重名的，则内“覆盖”外；</li>\n<li>注意：在<code>for循环</code>等语句块中<code>无法定义</code>具有局部作用域的变量；</li>\n<li>为了解决块级作用域，ES6引入了新的关键字<code>let</code>，用<code>let</code>替代<code>var</code>可以申明一个<code>块级作用域</code>的变量：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">   &apos;use strict&apos;;</div><div class=\"line\">   function foo() </div><div class=\"line\">&#123;</div><div class=\"line\">      var sum = 0;</div><div class=\"line\">      for (let i=0; i&lt;100; i++) </div><div class=\"line\">   &#123;</div><div class=\"line\">         sum += i;</div><div class=\"line\">      &#125;</div><div class=\"line\">      i += 1; // SyntaxError（如i用var定义则不出错）</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"三、常量\"><a href=\"#三、常量\" class=\"headerlink\" title=\"三、常量\"></a>三、常量</h2><ol>\n<li>使用<code>var</code>和<code>let</code>声明的是变量。<br>如果要申明一个常量，在ES6之前是不行的。<br>（通常用全部大写的变量来表示“这是一个常量，不要修改它的值”：<code>var  PI = 3.14;</code>）</li>\n<li>ES6标准引入了新的关键字<code>const</code>来定义<code>常量</code>，<br>const与let都具有块级作用域,<br>修改常量的值不出错，但无效：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&apos;use strict&apos;;</div><div class=\"line\">const PI = 3.14;</div><div class=\"line\">PI = 3; // 某些浏览器不报错，但是无效果！</div><div class=\"line\">PI; // 3.14</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"四、方法\"><a href=\"#四、方法\" class=\"headerlink\" title=\"四、方法\"></a>四、方法</h2><ol>\n<li><p>在一个对象中绑定函数，称为这个<code>对象的方法</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var 对象名=&#123;</div><div class=\"line\">   属性名：属性值</div><div class=\"line\">   属性名: 函数名或function () &#123; … &#125; //对象的方法</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>与普通函数的区别：它在内部使用了一个<code>this</code>关键字。<br><code>this</code>是一个特殊变量，它始终指向<code>当前对象</code>。</p>\n</li>\n<li><p>如果JavaScript的函数内部调用了this，这个this的指向分两种情况：</p>\n<ul>\n<li>第一种，以<code>xiaoming.age()</code>形式调用对象的方法。该函数的this指向被调用的对象，也就是<code>xiaoming标准对象</code>；</li>\n<li>第二种，以<code>getAge()</code>形式单独调用函数。该函数的this指向<code>全局对象window</code>，从而返回<code>NaN</code>;<br>另外，当为strict模式时函数的this又会指向<code>undefined</code>，因此在strict模式下亦会出错;<br>解决方法是用一个that变量先捕获this，就可放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">&apos;use strict&apos;;</div><div class=\"line\">var xiaoming = &#123;</div><div class=\"line\">    name: &apos;小明&apos;,</div><div class=\"line\">    birth: 1990,</div><div class=\"line\">    age: function () &#123;</div><div class=\"line\">       var that = this; // 在方法内部一开始就捕获this</div><div class=\"line\">       function getAgeFromBirth()</div><div class=\"line\">       &#123;</div><div class=\"line\">         var y = new Date().getFullYear();</div><div class=\"line\">         return y - that.birth; // 用that而不是this</div><div class=\"line\">       &#125;</div><div class=\"line\">       return getAgeFromBirth();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">xiaoming.age(); // 25（成功调用函数）</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p><code>apply()方法</code></p>\n<ul>\n<li>虽在一个独立的函数调用中，this根据是否是strict模式分别指向undefined或window，<br>但还是有方法可以<code>指定</code>函数的this指向哪个对象：用函数本身的<code>apply()方法</code></li>\n<li>apply方法接收两个参数：<br>1.需要绑定的this变量（表示this要指向的对象）<br>2.Array（数组形式添加）（表示函数本身的参数）</li>\n<li><p>实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">function getAge()</div><div class=\"line\">&#123;</div><div class=\"line\">       var y = new Date().getFullYear();</div><div class=\"line\">       return y - this.birth;</div><div class=\"line\">   &#125;</div><div class=\"line\">   var xiaoming = &#123;</div><div class=\"line\">       name: &apos;小明&apos;,</div><div class=\"line\">       birth: 1990,</div><div class=\"line\">       age: getAge  </div><div class=\"line\">   &#125;;</div><div class=\"line\">   xiaoming.age(); // 25</div><div class=\"line\">   getAge.apply(xiaoming, []); // 25（使this指向xiaoming, 参数为空）</div></pre></td></tr></table></figure>\n</li>\n<li><p>利用<code>apply()</code>，还可以动态改变函数的行为；<br>(JavaScript所有对象都是动态的，即使内置的函数，也可以重新指向新的函数)<br>实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">//需求：统计一下代码中一共调用了多少次parseInt()函数</div><div class=\"line\">//方法：动态改变parseInt函数的默认行为（免得要把所有的调用都找出来，然后手动加上count += 1）</div><div class=\"line\">var count = 0;</div><div class=\"line\">var oldParseInt = parseInt; // 保存原函数</div><div class=\"line\">window.parseInt = function () &#123;</div><div class=\"line\">   count += 1;</div><div class=\"line\">   return oldParseInt.apply(null, arguments); // 使用apply调用原函数</div><div class=\"line\">&#125;;</div><div class=\"line\">// 测试:</div><div class=\"line\">parseInt(&apos;10&apos;);</div><div class=\"line\">parseInt(&apos;20&apos;);</div><div class=\"line\">parseInt(&apos;30&apos;);</div><div class=\"line\">count; // 3</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p><code>call()方法</code></p>\n</li>\n</ol>\n<ul>\n<li>与<code>apply()</code>类似，唯一区别是：<br><code>apply()</code>把参数<code>打包成Array再传入</code>；<br><code>call()</code>把参数<code>按顺序传入</code>。</li>\n<li>比如调用<code>Math.max(3, 5, 4)</code>，<br>分别用apply()和call()实现如下：<br><code>Math.max.apply(null, [3, 5, 4]);</code> // 5<br><code>Math.max.call(null, 3, 5, 4);</code>    // 5 </li>\n</ul>\n<ol>\n<li>对普通函数调用时，通常把this绑定为null</li>\n</ol>\n<h2 id=\"五、高阶函数\"><a href=\"#五、高阶函数\" class=\"headerlink\" title=\"五、高阶函数\"></a>五、高阶函数</h2><ol>\n<li>定义：<code>一个函数接收另一个函数作为参数</code></li>\n<li><p>简单实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function add(x, y, f) </div><div class=\"line\">&#123;  </div><div class=\"line\">   return f(x) + f(y);   </div><div class=\"line\">&#125;</div><div class=\"line\">//调用：</div><div class=\"line\">add(-5, 6, Math.abs); // 11</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>map()方法</code>（Array）</p>\n<ul>\n<li>map()方法定义在JavaScript的Array中。<br>在调用Array的map()方法时通过传入自定义函数，可以得到一个新的Array作为结果，从而实现高阶函数</li>\n<li>语法：<br><code>arr.map( f(){…} );</code> 或 <code>arr.map(f);</code> //把f(x)作用在arr的每一个元素并把结果组合生成一个新的Array</li>\n<li>也可以把arr的所有数字转为字符串或数值：<br><code>arr.map(String);</code> //字符串<br><code>arr.map(Number);</code> //数值</li>\n</ul>\n</li>\n<li><p><code>reduce()方法</code>（Array）</p>\n<ul>\n<li>Array的reduce()可以把一个函数作用在这个Array的 [x1, x2, x3…]上</li>\n<li>这个函数必须接收两个参数(<code>被操作的数组名</code> 与 <code>操作函数名</code>)</li>\n<li>语法：<br><code>[x1, x2, x3, x4].reduce( f(.){...} )</code> //通过reduce()把结果继续和序列的下一个元素做f运算<br>相当于 <code>f(f(f(x1, x2), x3), x4)</code></li>\n<li>实例：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//对一个Array求和</div><div class=\"line\">var arr = [1, 3, 5, 7, 9];</div><div class=\"line\">arr.reduce(function (x, y)&#123;</div><div class=\"line\">     return x + y;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p><code>filter()方法</code>（Array）</p>\n<ul>\n<li>用于把Array的某些元素<code>过滤</code>掉，然后返回剩下的元素(相当于一个“筛选”函数)</li>\n<li>和map()类似也接收一个函数，<br>filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false来决定保留还是丢弃该元素</li>\n<li>规律：返回符合保留条件的，不符合条件的就自动筛选掉了</li>\n<li><p>实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//在一个Array中，只保留奇数，删掉偶数</div><div class=\"line\">var arr = [1, 2, 4, 5, 6, 9, 10, 15];</div><div class=\"line\">var r = arr.filter(function (x) &#123;</div><div class=\"line\">   return x % 2 !== 0; //若为奇数(true)则返回，否则保留</div><div class=\"line\">&#125;);</div><div class=\"line\">r; // [1, 5, 9, 15]</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>filter()</code>接收的回调函数还可以接收另外两个参数：<code>元素的位置</code>和<code>数组本身</code>(前面用的第一个参数，表示Array的某个元素)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];</div><div class=\"line\">var r = arr.filter(function (element, index, self) &#123;</div><div class=\"line\">  console.log(element); // 依次打印&apos;A&apos;, &apos;B&apos;, &apos;C&apos;</div><div class=\"line\">  console.log(index); // 依次打印0, 1, 2</div><div class=\"line\">  console.log(self); // self就是变量arr</div><div class=\"line\">  return true;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p>实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//利用filter，去除arr的重复元素</div><div class=\"line\">r = arr.filter(function (element, index, self) &#123;</div><div class=\"line\">  return self.indexOf(element) === index;</div><div class=\"line\">  //indexOf返回元素首次出现的位置，若与后续重复元素位置不相等(即重复了)，则被filter滤掉了</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p><code>sort()方法</code>（Array）</p>\n<ul>\n<li>默认把所有元素先转换为<code>String</code>，然后根据<code>字符串的ASCII码</code>进行排序</li>\n<li>排序结果跟往常不太相同(‘10’排在了’2’的前面，因为字符’1’比字符’2’的ASCII码小)</li>\n<li>幸好sort()方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序</li>\n<li>实例：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">//利用sort()实现按数字大小顺序排序：（逆序的话把return换一换就行）</div><div class=\"line\">var arr = [10, 20, 1, 2];</div><div class=\"line\">arr.sort(function (x, y) &#123;</div><div class=\"line\">    if (x &lt; y) &#123; return -1;&#125;</div><div class=\"line\">    if (x &gt; y) &#123; return 1; &#125;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;); // [1, 2, 10, 20]</div><div class=\"line\"></div><div class=\"line\">//实现忽略默认的ASCII大小写排序，而按照字母顺序的字符串排序，实际上就是先把字符串都变成大写（或者都变成小写），再比较：</div><div class=\"line\">//注意：sort()方法会直接对Array进行修改，它返回的结果仍是当前Array</div><div class=\"line\">var a1 = [&apos;B&apos;, &apos;A&apos;, &apos;C&apos;];</div><div class=\"line\">var a2 = a1.sort();</div><div class=\"line\">a1 === a2; // true, a1和a2是同一对象</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"六、闭包\"><a href=\"#六、闭包\" class=\"headerlink\" title=\"六、闭包\"></a>六、闭包</h2><ul>\n<li>高阶函数除了可以接受函数作为<code>参数</code>外，还可以把函数作为<code>结果值</code>返回</li>\n<li><p>实例：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">function sum(arr) </div><div class=\"line\">&#123;</div><div class=\"line\">     return arr.reduce(function (x, y) &#123;</div><div class=\"line\">         return x + y;</div><div class=\"line\">     &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">//若上面的求和函数不想立刻求和，而在后面的代码中根据需要再计算</div><div class=\"line\">//方法：可以不返回求和的结果，而是返回求和的函数</div><div class=\"line\">function lazy_sum(arr) </div><div class=\"line\">&#123;</div><div class=\"line\">     var sum = function () </div><div class=\"line\">     &#123;</div><div class=\"line\">         return arr.reduce(function (x, y) &#123;</div><div class=\"line\">              return x + y;</div><div class=\"line\">         &#125;);</div><div class=\"line\">     &#125;</div><div class=\"line\">     return sum;//返回求和的函数</div><div class=\"line\">&#125;</div><div class=\"line\">//当调用lazy_sum()时，返回的并不是求和结果，而是求和函数：</div><div class=\"line\">var f = lazy_sum([1, 2, 3, 4, 5]); // 返回function sum()</div><div class=\"line\">//当调用函数f时，才真正计算求和的结果：</div><div class=\"line\">f(); // 15</div></pre></td></tr></table></figure>\n</li>\n<li><p>在上面例子中，<br>函数sum在函数lazy_sum中定义，<br>并且内部函数sum可以引用外部函数lazy_sum的参数和局部变量，<br>当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，<br>这种称为“闭包（Closure）” </p>\n</li>\n<li>注意：当我们调用lazy_sum()时，每次调用都会返回一个<code>新的函数</code>，即使传入相同的参数；<br>并且，返回的函数并没有立刻执行，而是直到调用了<code>f()</code>才执行。</li>\n<li>注意：上例中返回的函数在其定义内部引用了<code>局部变量arr</code>，<br>即当一个函数返回了一个函数后，其内部的局部变量仍然被新函数引用；<br>所以返回闭包时牢记的一点：<code>返回函数不要引用任何循环变量 或 后续会发生变化的变量</code></li>\n<li>借助闭包，我们也可以在对象内部封装一个私有变量。<br>实际上就是返回一个携带了<code>局部变量x</code>的闭包，并且从外部代码根本无法访问到变量x(x即所谓私有变量)。<br>换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。</li>\n<li><p>闭包还可以把<code>多参数的函数</code>变成<code>单参数的函数</code>。<br>例如，要计算x^y可以用Math.pow(x, y)函数，<br>不过考虑到经常计算x^2或x^3，可以利用闭包创建新的函数pow2和pow3：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function make_pow(n) </div><div class=\"line\">&#123;</div><div class=\"line\">   return function (x) &#123;</div><div class=\"line\">     return Math.pow(x, n);</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">// 创建两个新函数:</div><div class=\"line\">var pow2 = make_pow(2);</div><div class=\"line\">var pow3 = make_pow(3);</div><div class=\"line\">pow2(5); // 25  //调用</div><div class=\"line\">pow3(7); // 343 //调用</div></pre></td></tr></table></figure>\n</li>\n<li><p>通常，一个立即执行的匿名函数可以把函数体拆开，一般这么写：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">(</div><div class=\"line\"> function (x) </div><div class=\"line\"> &#123;</div><div class=\"line\">   return x * x;</div><div class=\"line\"> &#125;</div><div class=\"line\">)(3);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"七、箭头函数\"><a href=\"#七、箭头函数\" class=\"headerlink\" title=\"七、箭头函数\"></a>七、箭头函数</h2><ul>\n<li>ES6标准新增了一种新的函数：<code>Arrow Function（箭头函数）</code></li>\n<li>语法：<br> <code>x =&gt; x * x</code>  // 相当于function (x) {  return x * x;  } </li>\n<li>箭头函数有两种格式：<ol>\n<li>只包含一个表达式，<code>省略</code>{ … }和return：<code>x =&gt; x * x</code></li>\n<li>包含多条语句，<code>不省略</code>{ … }和return：<code>x =&gt; {…return…}</code></li>\n</ol>\n</li>\n<li>参数种类：<ol>\n<li>无参数:  <code>() =&gt; 3.14</code></li>\n<li>两个参数: <code>(x, y) =&gt; x * x + y * y</code></li>\n<li>可变参数: <code>(x, y, ...rest) =&gt; {…}</code></li>\n</ol>\n</li>\n<li>如果要返回一个对象：<br><code>x =&gt; ( { foo: x } )</code> //不加括号就会出错(因为和函数体的{ … }有语法冲突)</li>\n<li>箭头函数类似匿名函数一样简化了函数定义，<br>但它们有个明显的区别：箭头函数内部的this是<code>词法作用域</code>，由上下文确定。<br>这样，使用箭头函数完全修复了this的指向，this总是指向词法作用域，也就是<code>外层调用者obj</code>： <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">var obj = &#123;</div><div class=\"line\">    birth: 1990,</div><div class=\"line\">    getAge: function () &#123;</div><div class=\"line\">        var b = this.birth; // 1990</div><div class=\"line\">        var fn = () =&gt; new Date().getFullYear() - this.birth; //this指向obj对象(而不是指向window或undefined)</div><div class=\"line\">        return fn();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">obj.getAge(); // 25</div><div class=\"line\">//注意：由于this在箭头函数中已经按照词法作用域绑定了</div><div class=\"line\">//所以用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略：</div><div class=\"line\">var obj = &#123;</div><div class=\"line\">   birth: 1990,</div><div class=\"line\">   getAge: function (year) &#123;</div><div class=\"line\">     var b = this.birth; // 1990</div><div class=\"line\">     var fn = (y) =&gt; y - this.birth; // this已经绑定了原对象obj，所以this.birth仍是1990</div><div class=\"line\">     return  fn.call ( &#123;birth:2000&#125; , year ); //传入的第一个参数无作用，因为this已经按词法作用域绑定了</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">obj.getAge(2015); // 25(而不是15)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"八、generator\"><a href=\"#八、generator\" class=\"headerlink\" title=\"八、generator\"></a>八、generator</h2><ul>\n<li><code>generator（生成器）</code>是ES6标准引入的新的数据类型；</li>\n<li>一个generator看上去像一个函数，但可以<code>返回多次</code>；</li>\n<li>generator由<code>function*</code>定义（注意多出的<code>*</code>号），<br>并且除了<code>return</code>语句，还可以用<code>yield</code>返回多次；</li>\n<li><p>语法：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function* foo(x) &#123;</div><div class=\"line\">  yield x + 1;</div><div class=\"line\">  yield x + 2;</div><div class=\"line\">  return x + 3;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>可以用<code>逐个输出</code>代替<code>最后才输出一个数组</code>的方式</p>\n</li>\n<li>创建generator对象：<br><code>foo(5);</code><br>或<br><code>var f= foo(5);</code>//用一个对象接收</li>\n<li><p>调用generator对象：</p>\n<ol>\n<li>不断地调用generator对象的<code>next()方法</code><br>1)语法：<code>generator对象.next();</code><br>2)next()方法会执行generator的代码，每次遇到yield xxx ,就返回一个对象<code>{value: x, done: true/false}</code>，然后“暂停”；<br>3)返回的value就是yield的返回值，done表示这个generator是否已经执行结束了；<br>4)当执行到done为true时，value就是return的返回值，这个generator对象已经全部执行完毕，不要再继续调用next()了。</li>\n<li>用<code>for ... of</code>循环迭代generator对象<br>语法：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (var x of foo(5)) </div><div class=\"line\">&#123; </div><div class=\"line\">   console.log(x); </div><div class=\"line\">&#125; </div><div class=\"line\">//这种方式不需要自己判断done的值</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p>因为generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数。<br>利用这一点，写一个generator就可以实现需要用面向对象才能实现的功能。<br>例如，用一个对象来保存状态</p>\n</li>\n<li>generator还可以把<code>异步回调代码</code>变成<code>“同步”代码</code>。<br>这个用途可应用到<code>AJAX</code>。</li>\n</ul>\n"}
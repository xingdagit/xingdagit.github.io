{"tags":[{"name":"JS","permalink":"http://yoursite.com/tags/JS/","url":"\\async\\tags\\JS.json","count":15}],"categories":[],"url":"\\async\\posts\\2017\\06\\01\\JS-函数.json","date":1496314261000,"path":{"year":2017,"month":6,"day":1,"name":"JS-函数"},"title":"JS-函数","permalink":"http://yoursite.com/2017/06/01/JS-函数/","content":"<h2 id=\"一、函数定义和调用\"><a href=\"#一、函数定义和调用\" class=\"headerlink\" title=\"一、函数定义和调用\"></a>一、函数定义和调用</h2><ol>\n<li>定义函数：function 函数名(参数) {…}<br>JavaScript的函数也是一个对象，函数名可视为指向该函数的变量，因此也可以这样定义函数：<br><code>var abs = function (x) {..}；</code></li>\n<li>调用函数：<br>1)在<code>&lt;script&gt;</code>标签内调用：<code>函数名(参数);</code><br>2)在HTML文件中调用，如通过点击按钮后调用已定义好的函数：<code>onclick=&quot;函数名(参数)&quot;</code><br>JavaScript允许传入任意个参数而不影响调用（过多忽略；过少即传入undefined）</li>\n<li>一旦执行到return时，函数就执行完毕，并将结果返回；如果没有return语句，函数执行完毕后也会返回结果，只是结果为undefined</li>\n<li><p>关键字arguments</p>\n<ul>\n<li>只在函数内部起作用</li>\n<li>利用arguments，可获得当前函数的调用者传入的所有参数</li>\n<li>即使函数不定义任何参数，还是可以拿到参数的值</li>\n<li><p>语法类似Array：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">   function foo(x) </div><div class=\"line\">&#123;</div><div class=\"line\">     alert(x); // 10</div><div class=\"line\">     for (var i=0; i&lt;arguments.length; i++) &#123;</div><div class=\"line\">       alert(arguments[i]); // 10, 20, 30</div><div class=\"line\">     &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   foo(10, 20, 30);</div></pre></td></tr></table></figure>\n</li>\n<li><p>最常用于判断传入参数的个数：arguments.length；</p>\n</li>\n<li>可用于把中间某参数变为“可选”参数，方法：通过arguments判断个数，然后重新调整参数并赋值</li>\n</ul>\n</li>\n<li>rest参数<ul>\n<li>ES6标准引入</li>\n<li>rest参数只能写在最后，前面用…标识</li>\n<li>变量rest用于以数组形式接收除已赋值给形参后剩余的参数（所以不再需要arguments就获取了全部参数）</li>\n<li>如果传入的参数连正常定义的参数都没填满，rest参数会接收一个空数组（注意不是undefined）</li>\n</ul>\n</li>\n<li>注意return语句：JavaScript引擎有一个在行末自动添加分号的机制，所以注意return与后面返回的东西不要隔行</li>\n</ol>\n<h2 id=\"二、变量作用域\"><a href=\"#二、变量作用域\" class=\"headerlink\" title=\"二、变量作用域\"></a>二、变量作用域</h2><ol>\n<li>在JavaScript中，用var申明的变量实际上是有作用域的</li>\n<li><p>变量提升</p>\n<ul>\n<li>JavaScript的函数定义有个特点：先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部</li>\n<li><p>实例: JavaScript引擎自动提升了变量y的声明，但不会提升变量y的赋值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&apos;use strict&apos;;</div><div class=\"line\">function foo() &#123;</div><div class=\"line\">   var x = &apos;Hello, &apos; + y;  //虽是strict模式，但并不报错，原因是变量y在稍后申明了</div><div class=\"line\">   alert(x);    //显示Hello, undefined，说明变量y的值为undefined</div><div class=\"line\">   var y = &apos;Bob&apos;;</div><div class=\"line\">&#125;</div><div class=\"line\">foo();</div></pre></td></tr></table></figure>\n</li>\n<li><p>由于这一“特性”，在函数内部定义变量时要严格遵守“在函数内部首先申明所有变量”这一规则。</p>\n</li>\n<li>最常见的做法是用一个var申明函数内部用到的所有变量：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">  var</div><div class=\"line\">      x = 1,      // x初始化为1</div><div class=\"line\">      y = x + 1,   // y初始化为2</div><div class=\"line\">      z, i;       // z和i为undefined</div><div class=\"line\">      …        // 其他语句:</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>全局作用域</p>\n<ul>\n<li>不在任何函数内定义的变量就具有全局作用域；</li>\n<li>JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性(调用：<code>window.全局变量名/全局变量名</code>)；</li>\n<li>以变量方式<code>var foo = function(){}</code>定义的函数实际上也是一个全局变量。所以顶层函数的定义也被视为一个全局变量，并绑定到window对象(调用：<code>window.foo()/foo()</code>)；</li>\n<li>不同的JavaScript文件如使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突；</li>\n<li>全局作用域只有一个，任何变量（函数也视为变量），如没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报ReferenceError错误；</li>\n<li>减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var MYAPP = &#123;&#125;;// 唯一的全局变量MYAPP</div><div class=\"line\">// 其他变量:</div><div class=\"line\">MYAPP.name = &apos;myapp&apos;;</div><div class=\"line\">MYAPP.version = 1.0;</div><div class=\"line\">// 其他函数:</div><div class=\"line\">MYAPP.foo = function () &#123; …. &#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>局部作用域</p>\n<ul>\n<li>JavaScript的变量作用域是函数内部；</li>\n<li>在for循环等语句块中是无法定义具有局部作用域的变量的；</li>\n<li>函数体内部申明的变量的作用域为整个函数体，不同函数内部的同名变量互相独立；</li>\n<li>对于嵌套的函数，内部函数可访问外部函数定义的变量，反过来则不行；若变量是重名的，则内“覆盖”外；</li>\n<li>为了解决块级作用域，ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&apos;use strict&apos;;</div><div class=\"line\">function foo() &#123;</div><div class=\"line\">   var sum = 0;</div><div class=\"line\">   for (let i=0; i&lt;100; i++) &#123;</div><div class=\"line\">      sum += i;</div><div class=\"line\">   &#125;</div><div class=\"line\">   i += 1; // SyntaxError（如i用var定义则不出错）</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"三、常量\"><a href=\"#三、常量\" class=\"headerlink\" title=\"三、常量\"></a>三、常量</h2><ol>\n<li>由于var和let申明的是变量，如果要申明一个常量，在ES6之前是不行的（通常用全部大写的变量来表示“这是一个常量，不要修改它的值”：<code>var  PI = 3.14;</code>）</li>\n<li>ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&apos;use strict&apos;;</div><div class=\"line\">const PI = 3.14;</div><div class=\"line\">PI = 3; // 某些浏览器不报错，但是无效果！</div><div class=\"line\">PI; // 3.14</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"四、方法\"><a href=\"#四、方法\" class=\"headerlink\" title=\"四、方法\"></a>四、方法</h2><ol>\n<li><p>在一个对象中绑定函数，称为这个对象的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Var 对象名=&#123;</div><div class=\"line\">  属性名：属性值</div><div class=\"line\">  属性名:  函数名或function () &#123; … &#125;//对象的方法</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>与普通函数的区别：它在内部使用了一个this关键字。this是一个特殊变量，它始终指向当前对象</p>\n</li>\n<li><p>如果JavaScript的函数内部调用了this，这个this的指向分两种情况：<br>1)如以对象的方法形式调用，如xiaoming.age()，该函数的this指向被调用的对象，也就是xiaoming标准对象；<br>2)如单独调用函数，如getAge()，该函数的this指向全局对象window，从而返回NaN(由于在strict模式下函数的this指向undefined，因此在strict模式下亦会出错)。<br>  解决方法是用一个that变量先捕获this，就可放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">&apos;use strict&apos;;</div><div class=\"line\">var xiaoming = &#123;</div><div class=\"line\">    name: &apos;小明&apos;,</div><div class=\"line\">    birth: 1990,</div><div class=\"line\">    age: function () </div><div class=\"line\">    &#123;</div><div class=\"line\">       var that = this; // 在方法内部一开始就捕获this</div><div class=\"line\">       function getAgeFromBirth()</div><div class=\"line\">       &#123;</div><div class=\"line\">         var y = new Date().getFullYear();</div><div class=\"line\">         return y - that.birth; // 用that而不是this</div><div class=\"line\">       &#125;</div><div class=\"line\">       return getAgeFromBirth();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">xiaoming.age(); // 25（成功调用函数）</div></pre></td></tr></table></figure>\n</li>\n<li><p>apply()</p>\n<ul>\n<li>虽在一个独立的函数调用中，this根据是否是strict模式分别指向undefined或window，但还是可以指定函数的this指向哪个对象：用函数本身的apply方法</li>\n<li>apply方法接收两个参数：1.需要绑定的this变量 和 2.Array（表示函数本身的参数）（数组形式添加）</li>\n<li><p>例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function getAge() &#123;</div><div class=\"line\">    var y = new Date().getFullYear();</div><div class=\"line\">    return y - this.birth;</div><div class=\"line\">&#125;</div><div class=\"line\">var xiaoming = &#123;</div><div class=\"line\">    name: &apos;小明&apos;,</div><div class=\"line\">    birth: 1990,</div><div class=\"line\">    age: getAge</div><div class=\"line\">&#125;;</div><div class=\"line\">xiaoming.age(); // 25</div><div class=\"line\">getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空</div></pre></td></tr></table></figure>\n</li>\n<li><p>利用apply()，还可以动态改变函数的行为(JavaScript所有对象都是动态的，即使内置的函数，也可以重新指向新的函数),实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">//需求：统计一下代码中一共调用了多少次parseInt()</div><div class=\"line\">//方法：动态改变parseInt函数的默认行为（免得要把所有的调用都找出来，然后手动加上count += 1）</div><div class=\"line\">var count = 0;</div><div class=\"line\">var oldParseInt = parseInt; // 保存原函数</div><div class=\"line\">window.parseInt = function () &#123;</div><div class=\"line\">  count += 1;</div><div class=\"line\">  return oldParseInt.apply(null, arguments); // 使用apply调用原函数</div><div class=\"line\">&#125;;</div><div class=\"line\">// 测试:</div><div class=\"line\">parseInt(&apos;10&apos;);</div><div class=\"line\">parseInt(&apos;20&apos;);</div><div class=\"line\">parseInt(&apos;30&apos;);</div><div class=\"line\">count; // 3</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>call()</p>\n</li>\n</ol>\n<ul>\n<li>与apply()类似，唯一区别是：apply()把参数打包成Array再传入；call()把参数按顺序传入。</li>\n<li>比如调用Math.max(3, 5, 4)，分别用apply()和call()实现如下：<br><code>Math.max.apply(null, [3, 5, 4]); // 5</code><br><code>Math.max.call(null, 3, 5, 4); // 5</code></li>\n</ul>\n<ol>\n<li>对普通函数调用时，通常把this绑定为null</li>\n</ol>\n<h2 id=\"五、高阶函数\"><a href=\"#五、高阶函数\" class=\"headerlink\" title=\"五、高阶函数\"></a>五、高阶函数</h2><ol>\n<li>定义：一个函数接收另一个函数作为参数</li>\n<li><p>简单实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function add(x, y, f) </div><div class=\"line\">&#123;  </div><div class=\"line\">   return f(x) + f(y);   </div><div class=\"line\">&#125;</div><div class=\"line\">//调用：</div><div class=\"line\">add(-5, 6, Math.abs); // 11</div></pre></td></tr></table></figure>\n</li>\n<li><p>map()方法（Array）</p>\n<ul>\n<li>由于map()方法定义在JavaScript的Array中，在调用Array的map()方法时传入自定义函数，得到一个新的Array作为结果，从而实现高阶函数</li>\n<li>语法：<code>arr.map( f(){ ….});</code> 或 `arr.map(f); //把f(x)作用在arr的每一个元素并把结果生成一个新的Array</li>\n<li>也可以把arr的所有数字转为字符串/数值：arr.map(String); / arr.map(Number); </li>\n</ul>\n</li>\n<li><p>reduce()方法（Array）</p>\n<ul>\n<li>Array的reduce()把一个函数作用在这个Array的 [x1, x2, x3…]上，这个函数必须接收两个参数(被操作的数组名与操作函数名)</li>\n<li>语法：<code>[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)</code> //通过reduce()把结果继续和序列的下一个元素做f运算</li>\n<li>实例：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//对一个Array求和</div><div class=\"line\">var arr = [1, 3, 5, 7, 9];</div><div class=\"line\">arr.reduce(function (x, y)&#123;</div><div class=\"line\">     return x + y;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>filter()方法（Array）</p>\n<ul>\n<li>用于把Array的某些元素过滤掉，然后返回剩下的元素(相当于一个“筛选”函数)</li>\n<li>和map()类似也接收一个函数，filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false来决定保留还是丢弃该元素</li>\n<li>规律：返回符合保留条件的，不符合条件的就自动筛选掉了</li>\n<li><p>实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//在一个Array中，只保留奇数，删掉偶数</div><div class=\"line\">var arr = [1, 2, 4, 5, 6, 9, 10, 15];</div><div class=\"line\">var r = arr.filter(function (x) &#123;</div><div class=\"line\">   return x % 2 !== 0; //是奇数就为true，就返回，就保留</div><div class=\"line\">&#125;);</div><div class=\"line\">r; // [1, 5, 9, 15]</div></pre></td></tr></table></figure>\n</li>\n<li><p>filter()接收的回调函数还可以接收另外两个参数：元素的位置和数组本身(前面用的第一个参数，表示Array的某个元素)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];</div><div class=\"line\">var r = arr.filter(function (element, index, self) &#123;</div><div class=\"line\">  console.log(element); // 依次打印&apos;A&apos;, &apos;B&apos;, &apos;C&apos;</div><div class=\"line\">  console.log(index); // 依次打印0, 1, 2</div><div class=\"line\">  console.log(self); // self就是变量arr</div><div class=\"line\">  return true;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p>实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//利用filter，去除arr的重复元素</div><div class=\"line\">r = arr.filter(function (element, index, self) &#123;</div><div class=\"line\">  return self.indexOf(element) === index;</div><div class=\"line\">  // indexOf返回元素首次出现的位置，若与后续重复元素位置不相等，则被filter滤掉了</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>sort()方法（Array）</p>\n<ul>\n<li>默认把所有元素先转换为String再排序，然后根据字符串的ASCII码进行排序</li>\n<li>排序结果跟往常不太相同(‘10’排在了’2’的前面，因为字符’1’比字符’2’的ASCII码小)</li>\n<li>幸好sort()方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序</li>\n<li>实例：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">//利用sort()实现按数字大小排序：（顺序排序）（逆序的话把return换一换就行）</div><div class=\"line\">var arr = [10, 20, 1, 2];</div><div class=\"line\">arr.sort(function (x, y) &#123;</div><div class=\"line\">    if (x &lt; y) &#123; return -1;&#125;</div><div class=\"line\">    if (x &gt; y) &#123; return 1; &#125;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;); // [1, 2, 10, 20]</div><div class=\"line\"></div><div class=\"line\">//实现忽略默认的ASCII大小写排序，而按照字母顺序的字符串排序。实际上就是先把字符串都变成大写（或者都变成小写），再比较：</div><div class=\"line\">//注意：sort()方法会直接对Array进行修改，它返回的结果仍是当前Array</div><div class=\"line\">var a1 = [&apos;B&apos;, &apos;A&apos;, &apos;C&apos;];</div><div class=\"line\">var a2 = a1.sort();</div><div class=\"line\">a1 === a2; // true, a1和a2是同一对象</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"六、闭包\"><a href=\"#六、闭包\" class=\"headerlink\" title=\"六、闭包\"></a>六、闭包</h2><ol>\n<li>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回</li>\n<li><p>实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">function sum(arr) &#123;</div><div class=\"line\">     return arr.reduce(function (x, y) &#123;</div><div class=\"line\">         return x + y;</div><div class=\"line\">     &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">//若上面的求和函数不想立刻求和，而在后面的代码中根据需要再计算</div><div class=\"line\">//方法：可以不返回求和的结果，而是返回求和的函数：</div><div class=\"line\">function lazy_sum(arr) </div><div class=\"line\">&#123;</div><div class=\"line\">     var sum = function () </div><div class=\"line\">     &#123;</div><div class=\"line\">         return arr.reduce(function (x, y) &#123;</div><div class=\"line\">              return x + y;</div><div class=\"line\">         &#125;);</div><div class=\"line\">     &#125;</div><div class=\"line\">     return sum;</div><div class=\"line\">&#125;</div><div class=\"line\">//当调用lazy_sum()时，返回的并不是求和结果，而是求和函数：</div><div class=\"line\">var f = lazy_sum([1, 2, 3, 4, 5]); // 返回function sum()</div><div class=\"line\">//调用函数f时，才真正计算求和的结果：</div><div class=\"line\">f(); // 15</div></pre></td></tr></table></figure>\n</li>\n<li><p>在上面例子中，函数sum在函数lazy_sum中定义，并且内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）” </p>\n</li>\n<li>注意：当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数；并且，返回的函数并没有立刻执行，而是直到调用了f()才执行</li>\n<li>注意：上例中返回的函数在其定义内部引用了局部变量arr，即当一个函数返回了一个函数后，其内部的局部变量仍然被新函数引用；所以返回闭包时牢记的一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量</li>\n<li>借助闭包，我们也可以在对象内部封装一个私有变量。实际上就是返回一个携带了局部变量x的闭包，并且从外部代码根本无法访问到变量x(x即所谓私有变量)。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来</li>\n<li><p>闭包还可以把多参数的函数变成单参数的函数。例如，要计算xy可以用Math.pow(x, y)函数，不过考虑到经常计算x2或x3，我们可以利用闭包创建新的函数pow2和pow3：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">function make_pow(n) &#123;</div><div class=\"line\">   return function (x) &#123;</div><div class=\"line\">     return Math.pow(x, n);</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">// 创建两个新函数:</div><div class=\"line\">var pow2 = make_pow(2);</div><div class=\"line\">var pow3 = make_pow(3);</div><div class=\"line\">pow2(5); // 25</div><div class=\"line\">pow3(7); // 343</div></pre></td></tr></table></figure>\n</li>\n<li><p>通常，一个立即执行的匿名函数可以把函数体拆开，一般这么写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(function (x) &#123;</div><div class=\"line\">   return x * x;</div><div class=\"line\">&#125;)(3);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"七、箭头函数\"><a href=\"#七、箭头函数\" class=\"headerlink\" title=\"七、箭头函数\"></a>七、箭头函数</h2><ol>\n<li>ES6标准新增了一种新的函数：<code>Arrow Function（箭头函数）</code></li>\n<li>语法：<code>x =&gt; x * x</code>  // 相当于function (x) {  return x * x;  } </li>\n<li>箭头函数有两种格式：<br>1)只包含一个表达式，省略{ … }和return ：x =&gt; x * x<br>2)包含多条语句，不省略{ … }和return：x =&gt; {…return…}</li>\n<li>参数种类：<br>1)无参数:  <code>() =&gt; 3.14</code><br>2)两个参数: <code>(x, y) =&gt; x * x + y * y</code><br>3)可变参数: <code>(x, y, ...rest) =&gt; {…}</code></li>\n<li>如果要返回一个对象：<code>x =&gt; ({ foo: x })</code> //不加括号就会出错(因为和函数体的{ … }有语法冲突)</li>\n<li>箭头函数类似匿名函数一样简化了函数定义，但它们有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。<br>这样，使用箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">var obj = &#123;</div><div class=\"line\">    birth: 1990,</div><div class=\"line\">    getAge: function () &#123;</div><div class=\"line\">        var b = this.birth; // 1990</div><div class=\"line\">        var fn = () =&gt; new Date().getFullYear() - this.birth; //this指向obj对象(而不是指向window或undefined)</div><div class=\"line\">        return fn();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">obj.getAge(); // 25</div><div class=\"line\">//注意：由于this在箭头函数中已经按照词法作用域绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略：</div><div class=\"line\">var obj = &#123;</div><div class=\"line\">   birth: 1990,</div><div class=\"line\">   getAge: function (year) &#123;</div><div class=\"line\">     var b = this.birth; // 1990</div><div class=\"line\">     var fn = (y) =&gt; y - this.birth; // this已经绑定了原对象obj，所以this.birth仍是1990</div><div class=\"line\">     return  fn.call ( &#123;birth:2000&#125;  , year );</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">obj.getAge(2015); // 25</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"八、generator\"><a href=\"#八、generator\" class=\"headerlink\" title=\"八、generator\"></a>八、generator</h2><ol>\n<li>generator（生成器）是ES6标准引入的新的数据类型；</li>\n<li>一个generator看上去像一个函数，但可以返回多次；</li>\n<li>generator由<code>function*</code>定义（注意多出的<code>*</code>号），并且除了<code>return</code>语句，还可以用<code>yield</code>返回多次；</li>\n<li><p>语法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function* foo(x) &#123;</div><div class=\"line\">  yield x + 1;</div><div class=\"line\">  yield x + 2;</div><div class=\"line\">  return x + 3;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>可以用逐个输出代替最后才输出一个数组的方式</p>\n</li>\n<li>创建generator对象：<code>foo(5);</code> 或 <code>var f= foo(5);</code>//用一个对象接收</li>\n<li><p>调用generator对象：<br>1)不断地调用generator对象的next()方法<br>  +语法：<code>f.next();</code><br>  +next()方法会执行generator的代码，每次遇到yield xxx ,就返回一个对象<code>{value: x, done: true/false}</code>，然后“暂停”；<br>  +返回的value就是yield的返回值，done表示这个generator是否已经执行结束了；<br>  +当执行到done为true时， value就是return的返回值，这个generator对象已经全部执行完毕，不要再继续调用next()了。<br>2)用<code>for ... of</code>循环迭代generator对象<br>  +语法：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (var x of foo(5)) &#123;</div><div class=\"line\">  console.log(x); </div><div class=\"line\">&#125;</div><div class=\"line\">//这种方式不需要我们自己判断done的值；</div></pre></td></tr></table></figure>\n</li>\n<li><p>因为generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数，利用这一点，写一个generator就可以实现需要用面向对象才能实现的功能。例如，用一个对象来保存状态</p>\n</li>\n<li>generator还可以把<code>异步回调代码</code>变成<code>“同步”代码</code>。这个用途可应用到<code>AJAX</code>。</li>\n</ol>\n"}
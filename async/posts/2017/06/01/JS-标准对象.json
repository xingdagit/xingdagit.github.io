{"tags":[{"name":"JS","permalink":"http://yoursite.com/tags/JS/","url":"\\async\\tags\\JS.json","count":8}],"categories":[],"url":"\\async\\posts\\2017\\06\\01\\JS-标准对象.json","date":1496322161000,"path":{"year":2017,"month":6,"day":1,"name":"JS-标准对象"},"title":"JS-标准对象","permalink":"http://yoursite.com/2017/06/01/JS-标准对象/","content":"<h3 id=\"一、在JavaScript里可谓一切都是对象-不能说对也不能说不对\"><a href=\"#一、在JavaScript里可谓一切都是对象-不能说对也不能说不对\" class=\"headerlink\" title=\"一、在JavaScript里可谓一切都是对象(不能说对也不能说不对)\"></a>一、在JavaScript里可谓一切都是对象(不能说对也不能说不对)</h3><p>第一，其实并不是一切皆对象，因为javascript有5种<code>基本数据类型</code>(Undefined、Null、Boolean、Number和String)和一个复杂数据类型(Object)<br>第二，但是在js的核心思想里：操作数据时，是将所有数据都视为对象进行操作的</p>\n<h3 id=\"二、为了区分对象的类型，用typeof操作符获取对象的类型，它总是返回一个字符串\"><a href=\"#二、为了区分对象的类型，用typeof操作符获取对象的类型，它总是返回一个字符串\" class=\"headerlink\" title=\"二、为了区分对象的类型，用typeof操作符获取对象的类型，它总是返回一个字符串\"></a>二、为了区分对象的类型，用typeof操作符获取对象的类型，它总是返回一个字符串</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">typeof 123; //返回 &apos;number&apos;</div><div class=\"line\">typeof NaN; // &apos;number&apos;</div><div class=\"line\">typeof &apos;str&apos;; // &apos;string&apos;</div><div class=\"line\">typeof true; // &apos;boolean&apos;</div><div class=\"line\">typeof undefined; // &apos;undefined&apos;</div><div class=\"line\">typeof Math.abs; // &apos;function&apos;</div><div class=\"line\">typeof null; // &apos;object&apos;</div><div class=\"line\">typeof []; // &apos;object&apos;</div><div class=\"line\">typeof &#123;&#125;; // &apos;object&apos;</div></pre></td></tr></table></figure>\n<h3 id=\"三、包装对象\"><a href=\"#三、包装对象\" class=\"headerlink\" title=\"三、包装对象\"></a>三、包装对象</h3><ul>\n<li>具有包装对象的类型：int、number、boolean和string </li>\n<li>用new创建包装对象<br><code>var n = new Number(123);</code> // 123,生成了新的包装类型<br><code>var b = new Boolean(true);</code> // true,生成了新的包装类型<br><code>var s = new String(&#39;str&#39;);</code>// ‘str’,生成了新的包装类型</li>\n<li>包装对象显示出来的值不变，但类型已经变为object(包装对象和原始值用===比较会返回false)</li>\n<li>因为这个原因少用包装对象(尤其是string类型)</li>\n<li>若在创建包装对象时没写new，则<code>Number()、Boolean和String()</code>等函数被当做普通函数，导致把任何类型的数据转换为<code>number、boolean和string</code>类型：<br> <code>var s = String(123.45); // &#39;123.45&#39;</code><br> <code>typeof s; // &#39;string&#39;</code></li>\n<li>使用包装对象需要遵守的几条规则：<ol>\n<li>不要使用new Number()、new Boolean()、new String()创建包装对象（即用构造函数的方式创建/实例化对象）。因为：包装对象创建/实例化出来的，是对象类型，而不是Number/Boolean/String类型。</li>\n<li>转换类型：<br>1)转为<code>number</code>类型：用parseInt() / parseFloat()；<br>2)转为<code>boolean</code>类型：通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {…}；<br>3)转为<code>string</code>类型：用String() /对象. toString()，但是注意：<br>  第一，null和undefined伪对象没有toString()方法；<br>  第二，整数number类型使用toSting()方法要在数末尾多加一个点或用括号括住数；</li>\n<li>判断类型：<br>typeof操作符可判断：number / boolean / string / function / undefined；<br>判断Array：<code>Array.isArray(myArr)；</code><br>判断null：<code>myVar === null；</code></li>\n<li>判断存在性：<br>判断某个全局变量是否存在：用<code>typeof window.myVar === &#39;undefined&#39;；</code><br>判断函数内部某个变量是否存在：用<code>typeof myVar === &#39;undefined&#39;；</code> </li>\n</ol>\n</li>\n</ul>\n<h3 id=\"1-Date对象\"><a href=\"#1-Date对象\" class=\"headerlink\" title=\"1.Date对象\"></a>1.Date对象</h3><ul>\n<li>Date对象用来表示日期和时间</li>\n<li><p>创建Date对象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var now = new Date();//获取系统当前时间(从本机操作系统获取的时间，不一定准确)</div><div class=\"line\">var d = new Date(2015, 5, 19, 20, 15, 30, 123); //创建一个指定日期和时间的Date对象</div><div class=\"line\">var d = Date.parse(&apos;2015-06-24T19:49:22.875+08:00&apos;);//创建一个指定日期和时间的方法(通过解析一个符合ISO 8601格式的字符串)</div><div class=\"line\">var d = new Date(时间戳数字串); //但返回的不是Date对象而是一个时间戳。于是再把时间戳转换为一个Date</div></pre></td></tr></table></figure>\n</li>\n<li><p>时间戳</p>\n<ul>\n<li>是一个<code>自增</code>的整数，它表示从<code>1970年1月1日零时整</code>的<code>GMT时区</code>开始那一刻到现在的<code>毫秒数</code>;</li>\n<li>时间戳可以精确地表示一个时刻，并且与时区无关;(世界上无论哪个时区的电脑，它们此刻产生的时间戳数字都是一样的)</li>\n<li>任何浏览器都可以把一个时间戳正确转换为本地时间;</li>\n<li>所以只需要传递时间戳或把时间戳从数据库里读出来，再让JavaScript自动转换就可以转为当地时间</li>\n<li>获取当前时间戳：<code>Date.now</code></li>\n</ul>\n</li>\n<li>Date对象的方法：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">now.getFullYear(); // 年份</div><div class=\"line\">now.getMonth(); // 月份，注意月份范围是0~11，5表示六月</div><div class=\"line\">now.getDate(); // 几号</div><div class=\"line\">now.getDay(); // 星期几</div><div class=\"line\">now.getHours(); // 时(24小时制)</div><div class=\"line\">now.getMinutes(); // 分钟</div><div class=\"line\">now.getSeconds(); // 秒</div><div class=\"line\">now.getMilliseconds(); // 毫秒数</div><div class=\"line\">now.getTime(); // 1435146562875(以number形式表示的时间戳)</div><div class=\"line\">now.toLocaleString(); // &apos;2015/6/24 下午7:49:22&apos;，本地时间（北京时区+8:00），显示的字符串与操作系统设定的格式有关</div><div class=\"line\">now.toUTCString(); // &apos;Wed, 24 Jun 2015 11:49:22 GMT&apos;，UTC时间，与本地时间相差8小时</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"2-RegExp\"><a href=\"#2-RegExp\" class=\"headerlink\" title=\"2.RegExp\"></a>2.RegExp</h3><ul>\n<li>正则表达式<br>1)精确匹配：直接给出全部字符<br>2)模糊匹配：用<code>\\d</code>可匹配一个<code>数字</code>，<code>\\w</code>可匹配一个<code>字母或数字</code>，<code>\\s</code>可匹配一个<code>空格（包括Tab等空白符），</code>\\s+<code>可匹配</code>至少一个空格`（例如匹配’ ‘，’\\t\\t’）</li>\n<li>用<code>*</code>表示任意个字符（包括0个）；</li>\n<li>用<code>+</code>表示至少一个字符；</li>\n<li>用<code>.</code>可以匹配任意字符；</li>\n<li>用<code>?</code>表示0个或1个字符；</li>\n<li>用<code>{n}</code>表示n个字符；</li>\n<li>用<code>{n,m}</code>表示n-m个字符；</li>\n<li><code>A|B</code>可以匹配A或B，所以<code>(J|j)ava(S|s)cript</code>可以匹配’JavaScript’、’Javascript’、’javaScript’或者’javascript’；</li>\n<li><code>^</code>表示行的开头，<code>^\\d</code>表示必须以数字开头；</li>\n<li><code>$</code>表示行的结束，<code>\\d$</code>表示必须以数字结束；</li>\n<li><code>空格</code>也算入匹配范围</li>\n<li>用<code>[]</code>表示范围可以更精确地匹配；</li>\n<li>特殊字符，在正则表达式中要用<code>\\</code>转义；</li>\n<li>例子:<ul>\n<li><code>00\\d</code>可匹配<code>007</code>，但无法匹配<code>00A</code>；</li>\n<li><code>\\d\\d\\d</code>可匹配<code>010</code>；</li>\n<li><code>\\w\\w</code>可匹配<code>js</code>;</li>\n<li><code>js.</code>可匹配 <code>&#39;jsp&#39;、&#39;jss&#39;、&#39;js!&#39;</code>等等</li>\n<li><code>[0-9a-zA-Z\\_]</code>可以匹配<code>一个数字、字母或者下划线</code>；</li>\n<li><code>[0-9a-zA-Z\\_]+</code>可以匹配<code>至少由一个数字、字母或者下划线组成的字符串</code>，比如’a100’，’0_Z’，’js2015’等等；</li>\n<li><code>[a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]*</code>可以匹配<code>由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串</code>，也就是JavaScript允许的变量名；</li>\n<li><code>[a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]{0, 19}</code>更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。</li>\n</ul>\n</li>\n<li>创建一个正则表达式<br>直接通过<code>/正则表达式/</code>写出来：<code>var re1 = /ABC\\-001/;</code><br>通过<code>new RegExp(&#39;正则表达式&#39;)</code>创建一个RegExp对象：<br>   <code>var re2 = new RegExp(&#39;ABC\\\\-001&#39;);</code>//这种方式存在字符串的转义问题</li>\n<li><p>RegExp对象的<code>test()</code>方法用于测试给定的字符串是否符合条件:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var re = /^\\d&#123;3&#125;\\-\\d&#123;3,8&#125;$/;</div><div class=\"line\">re.test(&apos;010-12345&apos;); // true</div><div class=\"line\">re.test(&apos;010-1234x&apos;); // false</div></pre></td></tr></table></figure>\n</li>\n<li><p>切分字符串<br>用正则表达式切分字符串比用固定的字符更灵活；<br>用正则表达式可把不规范的输入转化成正确的数组；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">a b   c&apos;.split(&apos; &apos;);     // [&apos;a&apos;, &apos;b&apos;, &apos;&apos;, &apos;&apos;, &apos;c&apos; ]，无法识别连续的空格</div><div class=\"line\">&apos;a b   c&apos;.split(/\\s+/);  // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]，使用正则表达式无论多少个空格都可以正常分割了</div><div class=\"line\">&apos;a,b, c  d&apos;.split(/[\\s\\,]+/);   // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]，加入`,`的识别</div><div class=\"line\">&apos;a,b;; c  d&apos;.split(/[\\s\\,\\;]+/);  // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]，加入`;`的识别</div></pre></td></tr></table></figure>\n</li>\n<li><p>分组</p>\n<ul>\n<li>正则表达式还有提取子串的强大功能；</li>\n<li>RegExp对象的exec()方法用于提取出符合格式的子串；</li>\n<li>exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串；在匹配失败时返回null。</li>\n<li><p>实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//从匹配的字符串中提取出区号和本地号码</div><div class=\"line\">var re = /^(\\d&#123;3&#125;)-(\\d&#123;3,8&#125;)$/;</div><div class=\"line\">re.exec(&apos;010-12345&apos;); // [&apos;010-12345&apos;, &apos;010&apos;, &apos;12345&apos;]</div><div class=\"line\">re.exec(&apos;010 12345&apos;); // null</div></pre></td></tr></table></figure>\n</li>\n<li><p>有时候用正则表达式也无法做到完全验证，比如识别日期</p>\n</li>\n</ul>\n</li>\n<li><p>贪婪匹配</p>\n<ul>\n<li>正则匹配默认是贪婪匹配，即匹配尽可能多的字符；</li>\n<li>比如匹配出数字后面的0：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var re = /^(\\d+)(0*)$/;</div><div class=\"line\">re.exec(&apos;102300&apos;); // [&apos;102300&apos;, &apos;102300&apos;, &apos;&apos;]     (由于\\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了)</div><div class=\"line\">//必须让\\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来:</div><div class=\"line\">var re = /^(\\d+?)(0*)$/;  //加个?就可以让\\d+采用非贪婪匹配</div><div class=\"line\">re.exec(&apos;102300&apos;); // [&apos;102300&apos;, &apos;1023&apos;, &apos;00&apos;]</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>全局搜索</p>\n<ul>\n<li>JavaScript的正则表达式还有几个特殊的标志，最常用的是<code>g</code>，表示<code>全局匹配</code>：<br><code>var r1 = /test/g;</code> //等价于 <code>var r2 = new RegExp(&#39;test&#39;, &#39;g&#39;);</code></li>\n<li>全局匹配可以多次执行<code>exec()</code>方法来搜索一个匹配的字符串，每运行exec()一次正则表达式本身会更新lastIndex属性一次，表示上次匹配到的最后索引；</li>\n<li>全局匹配类似搜索，因此不能使用<code>/^...$/</code>，那样只会最多匹配一次；</li>\n<li>正则表达式还可以指定i标志，表示忽略大小写，m标志，表示执行多行匹配。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-JSON\"><a href=\"#3-JSON\" class=\"headerlink\" title=\"3.JSON\"></a>3.JSON</h3><ul>\n<li>JavaScript Object Notation</li>\n<li>一种超轻量级的数据交换格式</li>\n<li>因XML的规范的复杂，JSON逐渐取代XML来传递数据</li>\n<li>JSON实际上是JavaScript的一个子集，JavaScript内置了JSON的解析</li>\n<li>JSON的数据类型：<br>　- number：和JavaScript的number完全一致；<br>　- boolean：就是JavaScript的true或false；<br>　- string：就是JavaScript的string；<br>　- null：就是JavaScript的null；<br>　- array：就是JavaScript的Array表示方式——[]；<br>　- object：就是JavaScript的{ … }表示方式；<br>　- 以及上面的任意组合。</li>\n<li>JSON规定了字符集必须是<code>UTF-8</code>，因此不能表示多语言。为了统一解析，JSON的字符串规定必须用双引号””，Object的键也必须用双引号””。</li>\n<li>把任何JavaScript对象变成JSON，相当于把这个对象序列化成一个JSON格式的字符串，从而才能够通过网络传递给其他计算机；当收到一个JSON格式的字符串，只需把它反序列化成一个JavaScript对象，就可在JavaScript中直接使用这个对象了</li>\n<li><p>序列化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">//把xiaoming对象序列化成JSON格式的字符串：</div><div class=\"line\">var xiaoming = &#123;</div><div class=\"line\">    name: &apos;小明&apos;,</div><div class=\"line\">    age: 14,</div><div class=\"line\">    gender: true,</div><div class=\"line\">    height: 1.65,</div><div class=\"line\">    grade: null,</div><div class=\"line\">    &apos;middle-school&apos;: &apos;\\&quot;W3C\\&quot; Middle School&apos;,</div><div class=\"line\">    skills: [&apos;JavaScript&apos;, &apos;Java&apos;, &apos;Python&apos;, &apos;Lisp&apos;]</div><div class=\"line\">&#125;;</div><div class=\"line\">JSON.stringify(xiaoming); // &apos;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14,&quot;gender&quot;:true,&quot;height&quot;:1.65,&quot;grade&quot;:null,&quot;middle-school&quot;:&quot;\\&quot;W3C\\&quot; Middle School&quot;,&quot;skills&quot;:[&quot;JavaScript&quot;,&quot;Java&quot;,&quot;Python&quot;,&quot;Lisp&quot;]&#125;&apos;</div><div class=\"line\"></div><div class=\"line\">//若要输出得好看一些，可以加上参数来按缩进输出</div><div class=\"line\">JSON.stringify(xiaoming, null, &apos;  &apos;);</div><div class=\"line\"></div><div class=\"line\">//第二个参数用于控制如何筛选对象的键值，如只想输出指定的属性，可以传入Array：</div><div class=\"line\">JSON.stringify(xiaoming, [&apos;name&apos;, &apos;skills&apos;], &apos;  &apos;);</div><div class=\"line\"></div><div class=\"line\">//第二个参数还可传入一个函数，这样对象的每个键值对都会被函数先处理：</div><div class=\"line\">JSON.stringify(xiaoming, convert, &apos;  &apos;); //convert函数定义省略</div><div class=\"line\"></div><div class=\"line\">//可给xiaoming定义一个toJSON()的方法，规定要返回JSON序列化的数据</div><div class=\"line\">var xiaoming = &#123;</div><div class=\"line\">    name: &apos;小明&apos;,</div><div class=\"line\">    age: 14,</div><div class=\"line\">    …..</div><div class=\"line\">    toJSON: function () &#123;</div><div class=\"line\">        return &#123; &apos;Name&apos;: this.name , &apos;Age&apos;: this.age &#125;; //只输出name和age，并且改变了key：</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">JSON.stringify(xiaoming); // &apos;&#123;&quot;Name&quot;:&quot;小明&quot;,&quot;Age&quot;:14&#125;&apos;</div></pre></td></tr></table></figure>\n</li>\n<li><p>反序列化</p>\n</li>\n</ul>\n<ol>\n<li><p>拿到一个JSON格式的字符串，用<code>JSON.parse()</code>把它变成一个JavaScript对象：<br>　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">　JSON.parse(&apos;[1,2,3,true]&apos;); // [1, 2, 3, true]</div><div class=\"line\">　JSON.parse(&apos;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14&#125;&apos;); // Object &#123;name: &apos;小明&apos;, age: 14&#125;</div><div class=\"line\">　JSON.parse(&apos;true&apos;); // true</div><div class=\"line\">　JSON.parse(&apos;123.45&apos;); // 123.45</div></pre></td></tr></table></figure></p>\n</li>\n<li><p>JSON.parse()还可接收一个<code>函数</code>，用来转换、修改解析出的属性值：<br>　<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">　JSON.parse(&apos;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14&#125;&apos;, function (key, value) &#123;</div><div class=\"line\">　　if (key === &apos;name&apos;) &#123;  return value + &apos;同学&apos;;  &#125;</div><div class=\"line\">　　return value;</div><div class=\"line\">　&#125;); </div><div class=\"line\">　// Object &#123;name: &apos;小明同学&apos;, age: 14&#125;</div></pre></td></tr></table></figure></p>\n</li>\n</ol>\n"}
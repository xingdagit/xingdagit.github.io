{"tags":[{"name":"underscore","permalink":"http://yoursite.com/tags/underscore/","url":"\\async\\tags\\underscore.json","count":4}],"categories":[],"url":"\\async\\posts\\2017\\06\\05\\underscore-Functions.json","date":1496677041000,"path":{"year":2017,"month":6,"day":5,"name":"underscore-Functions"},"title":"underscore-Functions","permalink":"http://yoursite.com/2017/06/05/underscore-Functions/","content":"<h3 id=\"Functions\"><a href=\"#Functions\" class=\"headerlink\" title=\"Functions\"></a>Functions</h3><p>因为underscore本来就是为了充分发挥JavaScript的<code>函数式编程特性</code>，所以也提供了大量JavaScript本身没有的<code>高阶函数</code>。</p>\n<ol>\n<li><p>bind()</p>\n<ul>\n<li>可以把将传入参数（如一个对象）直接绑定在一个函数的<code>this指针</code>上，从而更方便调用函数</li>\n<li><p>实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">    console.log(&apos;Hello, world!&apos;);// 输出&apos;Hello, world!&apos;</div><div class=\"line\">    //若想用log()取代console.log()，更方便地输出：</div><div class=\"line\">\t//1.这方法不行，因为直接调用log()传入的this指针是undefined：</div><div class=\"line\">    var log = console.log;</div><div class=\"line\">    log(&apos;Hello, world!&apos;);// Uncaught TypeError: Illegal invocation</div><div class=\"line\">\t//小知识：&quot;独立调用一个函数，严格模式下this指向undefined，非严格模式下this指向window&quot;</div><div class=\"line\">\t</div><div class=\"line\">\t//2.可以调用call并传入console对象作为this，但好像更麻烦了:</div><div class=\"line\">    log.call(console, &apos;Hello, world!&apos;);// 输出Hello, world!</div><div class=\"line\">\t</div><div class=\"line\">\t//3.用bind()把console对象直接绑定在log()的this指针上，就可以直接正常调用log()来输出了</div><div class=\"line\">\tvar log = _.bind(console.log, console);</div><div class=\"line\">\tlog(&apos;Hello, world!&apos;);  // 输出Hello, world!</div><div class=\"line\">    ```\t</div><div class=\"line\"></div><div class=\"line\">2. partial()</div><div class=\"line\">  - 认识`偏函数`：</div><div class=\"line\">    假设要计算`x^y`，这时只需调用`Math.pow(x, y)`就可以了；</div><div class=\"line\">    但当要经常计算`2^y`，每次都写`Math.pow(2, y)`就比较麻烦；</div><div class=\"line\">\t那我们就可以创建一个新的函数`pow2N(y)`，实现更方便调用；</div><div class=\"line\">\t这个新函数`pow2N(y)`就是根据`Math.pow(x, y)`创建出来的`偏函数`，它固定住了原函数的第一个参数（始终为2）</div><div class=\"line\">  - 可见创建`偏函数`的目的是将原函数的某些参数固定住，从而降低新函数调用的难度。\t</div><div class=\"line\">  - `partial()`的作用就是为一个函数创建`偏函数`；</div><div class=\"line\">  - 第一个参数为要参考的函数名，后面的参数即为原来传入参考函数的参数（可自己决定固定或不固定这些参数，不固定的用`_`代替）；</div><div class=\"line\">  - 例子：</div></pre></td></tr></table></figure>\n<p>//计算2的n次方（固定第一个参数为2）：<br>var pow2N = <em>.partial(Math.pow, 2);<br>pow2N(3); // 8<br>pow2N(5); // 32<br>pow2N(10); // 1024<br>//计算n的3次方（固定第三个参数为3）：<br>var cube = </em>.partial(Math.pow, _ , 3);<br>cube(3); // 27<br>cube(5); // 125<br>cube(10); // 1000</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">3. memoize()</div><div class=\"line\">  - 如果一个函数调用开销、耗时很大(计算过程长且数据多)（如计算阶乘），就希望能把结果缓存下来，以便后续调用时直接获得结果。</div><div class=\"line\">  - `memoize()`的作用就是`自动缓存函数计算的结果`。</div><div class=\"line\">  - 例子：</div></pre></td></tr></table></figure>\n<p>var factorial = _.memoize(function(n) {<br>  //计算n的阶乘n!<br>  console.log(‘开始计算’ + n + ‘!…’);<br>  var s = 1, i = n;<br>  while (i &gt; 1)<br>  {</p>\n<pre><code>s = s * i;\ni --;\n</code></pre><p>  }<br>  console.log(n + ‘! = ‘ + s);<br>  return s;<br>}<br>// 第一次调用:<br>factorial(10); // 3628800<br>// 注意控制台输出:<br>// start calculate 10!…<br>// 10! = 3628800</p>\n<p>//第一次调用后已自动缓存函数计算结果</p>\n<p>// 第二次调用并没有计算，而是直接返回上次计算后缓存的结果:<br>factorial(10); // 3628800<br>// 控制台没有输出</p>\n<p>//但是一换了参数，仍然会重新计算：<br>factorial(9); //会重新计算<br>//对factorial()函数改进为递归调用，就可以了：<br>var factorial = _.memoize(function(n) {<br>  console.log(‘start calculate ‘ + n + ‘!…’);<br>  if (n &lt; 2) {</p>\n<pre><code>return 1;\n</code></pre><p>  }<br>  return n * factorial(n - 1);<br>});<br>factorial(9); // 362880<br>// console无输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">4. once()</div><div class=\"line\">  - `once()`保证某个函数执行且仅执行一次。</div><div class=\"line\">  - 如果用户在页面上点两个按钮中任何一个都可以执行某函数的话，就可以用`once()`保证函数仅调用一次，无论用户点击多少次：</div></pre></td></tr></table></figure>\n<p>var register = _.once(function () {<br>   alert(‘已经点过了!’);<br>});</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">5. delay()</div><div class=\"line\">  - `delay()`可以让一个函数延迟执行，效果和setTimeout()一样，但代码明显简单了：</div></pre></td></tr></table></figure>\n<p>_.delay(alert, 2000);// 2秒后调用alert()</p>\n<p>// 如果要延迟调用的函数有参数，把参数也传进去：<br>var log = <em>.bind(console.log, console);\n</em>.delay(log, 2000, ‘Hello,world!’); // 2秒后打印’Hello, world!’:<br>```</p>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>更多完整<code>Functions</code>函数请参考underscore的文档：<a href=\"http://underscorejs.org/#functions\" target=\"_blank\" rel=\"external\">http://underscorejs.org/#functions</a></li>\n</ul>\n"}
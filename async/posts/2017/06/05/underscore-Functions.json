{"tags":[{"name":"underscore","permalink":"http://yoursite.com/tags/underscore/","url":"\\async\\tags\\underscore.json","count":4}],"categories":[],"url":"\\async\\posts\\2017\\06\\05\\underscore-Functions.json","date":1496677041000,"path":{"year":2017,"month":6,"day":5,"name":"underscore-Functions"},"title":"underscore-Functions","permalink":"http://yoursite.com/2017/06/05/underscore-Functions/","content":"<h3 id=\"Functions\"><a href=\"#Functions\" class=\"headerlink\" title=\"Functions\"></a>Functions</h3><p>因为underscore本来就是为了充分发挥JavaScript的<code>函数式编程特性</code>，所以也提供了大量JavaScript本身没有的<code>高阶函数</code>。</p>\n<ol>\n<li><p>bind()</p>\n<ul>\n<li>可以把将传入参数（如一个对象）直接绑定在一个函数的<code>this指针</code>上，从而更方便调用函数</li>\n<li>实例：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">  console.log(&apos;Hello, world!&apos;);// 输出&apos;Hello, world!&apos; </div><div class=\"line\">  //若想用log()取代console.log()，更方便地输出： </div><div class=\"line\">  //1.这方法不行，因为直接调用log()传入的this指针是undefined： </div><div class=\"line\">  var log = console.log; </div><div class=\"line\">  log(&apos;Hello, world!&apos;);// Uncaught TypeError: Illegal invocation </div><div class=\"line\">  //小知识：&quot;独立调用一个函数，严格模式下this指向undefined，非严格模式下this指向window&quot; </div><div class=\"line\">  //2.可以调用call并传入console对象作为this，但好像更麻烦了: </div><div class=\"line\">  log.call(console, &apos;Hello, world!&apos;);// 输出Hello, world! </div><div class=\"line\">  //3.用bind()把console对象直接绑定在log()的this指针上，就可以直接正常调用log()来输出了 </div><div class=\"line\">  var log = _.bind(console.log, console); </div><div class=\"line\">  log(&apos;Hello, world!&apos;); // 输出Hello, world! </div><div class=\"line\">  ```\t</div><div class=\"line\"></div><div class=\"line\">2. partial()</div><div class=\"line\">  - 认识`偏函数`：</div><div class=\"line\">    假设要计算`x^y`，这时只需调用`Math.pow(x, y)`就可以了；</div><div class=\"line\">    但当要经常计算`2^y`，每次都写`Math.pow(2, y)`就比较麻烦；</div><div class=\"line\">\t那我们就可以创建一个新的函数`pow2N(y)`，实现更方便调用；</div><div class=\"line\">\t这个新函数`pow2N(y)`就是根据`Math.pow(x, y)`创建出来的`偏函数`，它固定住了原函数的第一个参数（始终为2）</div><div class=\"line\">  - 可见创建`偏函数`的目的是将原函数的某些参数固定住，从而降低新函数调用的难度。\t</div><div class=\"line\">  - `partial()`的作用就是为一个函数创建`偏函数`；</div><div class=\"line\">  - 第一个参数为要参考的函数名，后面的参数即为原来传入参考函数的参数（可自己决定固定或不固定这些参数，不固定的用`_`代替）；</div><div class=\"line\">  - 例子：</div><div class=\"line\">  ``` </div><div class=\"line\">  //计算2的n次方（固定第一个参数为2）： </div><div class=\"line\">  var pow2N = _.partial(Math.pow, 2); </div><div class=\"line\">  pow2N(3); // 8 </div><div class=\"line\">  pow2N(5); // 32 </div><div class=\"line\">  pow2N(10); // 1024 </div><div class=\"line\">  //计算n的3次方（固定第三个参数为3）： </div><div class=\"line\">  var cube = _.partial(Math.pow, _ , 3); </div><div class=\"line\">  cube(3); // 27 </div><div class=\"line\">  cube(5); // 125 </div><div class=\"line\">  cube(10); // 1000</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>memoize()</p>\n<ul>\n<li>如果一个函数调用开销、耗时很大(计算过程长且数据多)（如计算阶乘），就希望能把结果缓存下来，以便后续调用时直接获得结果。</li>\n<li><code>memoize()</code>的作用就是<code>自动缓存函数计算的结果</code>。</li>\n<li>例子：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"> var factorial = _.memoize(function(n) &#123; </div><div class=\"line\">   //计算n的阶乘n! console.log(&apos;开始计算&apos; + n + &apos;!...&apos;); </div><div class=\"line\">var s = 1, i = n; </div><div class=\"line\">while (i &gt; 1) </div><div class=\"line\">&#123; </div><div class=\"line\">  s = s * i; </div><div class=\"line\">  i --; </div><div class=\"line\">&#125; </div><div class=\"line\">console.log(n + &apos;! = &apos; + s); </div><div class=\"line\">return s; </div><div class=\"line\"> &#125; </div><div class=\"line\"> // 第一次调用: factorial(10); // 3628800 </div><div class=\"line\"> // 注意控制台输出: </div><div class=\"line\"> // start calculate 10!... </div><div class=\"line\"> // 10! = 3628800 </div><div class=\"line\"> //第一次调用后已自动缓存函数计算结果 </div><div class=\"line\"> //第二次调用并没有计算，而是直接返回上次计算后缓存的结果: </div><div class=\"line\"> factorial(10); // 3628800 </div><div class=\"line\"> // 控制台没有输出 </div><div class=\"line\"> //但是一换了参数，仍然会重新计算： </div><div class=\"line\"> factorial(9); //会重新计算 </div><div class=\"line\"> //对factorial()函数改进为递归调用，就可以了： </div><div class=\"line\"> var factorial = _.memoize(function(n) &#123; </div><div class=\"line\">    console.log(&apos;start calculate &apos; + n + &apos;!...&apos;); </div><div class=\"line\"> if (n &lt; 2) </div><div class=\"line\"> &#123; </div><div class=\"line\">   return 1; </div><div class=\"line\"> &#125; </div><div class=\"line\"> return n * factorial(n - 1); </div><div class=\"line\"> &#125;); </div><div class=\"line\"> factorial(9); // 362880 </div><div class=\"line\"> // console无输出</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>once()</p>\n<ul>\n<li><code>once()</code>保证某个函数执行且仅执行一次。</li>\n<li>如果用户在页面上点两个按钮中任何一个都可以执行某函数的话，就可以用<code>once()</code>保证函数仅调用一次，无论用户点击多少次：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var register = _.once(function () &#123; </div><div class=\"line\">  alert(&apos;已经点过了!&apos;); </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>delay()</p>\n<ul>\n<li><code>delay()</code>可以让一个函数延迟执行，效果和setTimeout()一样，但代码明显简单了：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">_.delay(alert, 2000);// 2秒后调用alert() </div><div class=\"line\">// 如果要延迟调用的函数有参数，把参数也传进去： </div><div class=\"line\">var log = _.bind(console.log, console); </div><div class=\"line\">_.delay(log, 2000, &apos;Hello,world!&apos;); // 2秒后打印&apos;Hello, world!&apos;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>更多完整<code>Functions</code>函数请参考underscore的文档：<a href=\"http://underscorejs.org/#functions\" target=\"_blank\" rel=\"external\">http://underscorejs.org/#functions</a></li>\n</ul>\n"}
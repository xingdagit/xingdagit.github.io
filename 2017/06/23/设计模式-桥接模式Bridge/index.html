<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      设计模式-桥接模式Bridge | SPACE-19 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
    

    <meta name="description" content="一、桥接模式(Bridge Pattern) 桥接模式属于结构型模式。 桥接模式是一个非常实用的模式，在桥接模式中体现了很多面向对象设计原则的思想，包括单一职责原则、开闭原则、合成复用原则、里氏代换原则、依赖倒转原则等。熟悉桥接模式有助于我们深入理解这些设计原则，也有助于我们形成正确的设计思想和培养良好的设计风格。  二、模式动机 在软件系统中，有些类由于其本身的固有特性，使得它有两个或多个变化维">
<meta name="keywords" content="设计模式">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式-桥接模式Bridge | SPACE-19">
<meta property="og:url" content="http://yoursite.com/2017/06/23/设计模式-桥接模式Bridge/index.html">
<meta property="og:site_name" content="SPACE-19">
<meta property="og:description" content="一、桥接模式(Bridge Pattern) 桥接模式属于结构型模式。 桥接模式是一个非常实用的模式，在桥接模式中体现了很多面向对象设计原则的思想，包括单一职责原则、开闭原则、合成复用原则、里氏代换原则、依赖倒转原则等。熟悉桥接模式有助于我们深入理解这些设计原则，也有助于我们形成正确的设计思想和培养良好的设计风格。  二、模式动机 在软件系统中，有些类由于其本身的固有特性，使得它有两个或多个变化维">
<meta property="og:image" content="https://ooo.0o0.ooo/2017/06/23/594d2c06d4678.jpg">
<meta property="og:image" content="https://ooo.0o0.ooo/2017/06/23/594d32bee3e7a.jpg">
<meta property="og:image" content="https://ooo.0o0.ooo/2017/06/24/594d4cea7ec64.jpg">
<meta property="og:image" content="https://ooo.0o0.ooo/2017/06/24/594d4e62980b2.jpg">
<meta property="og:updated_time" content="2017-06-24T03:28:23.894Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="设计模式-桥接模式Bridge | SPACE-19">
<meta name="twitter:description" content="一、桥接模式(Bridge Pattern) 桥接模式属于结构型模式。 桥接模式是一个非常实用的模式，在桥接模式中体现了很多面向对象设计原则的思想，包括单一职责原则、开闭原则、合成复用原则、里氏代换原则、依赖倒转原则等。熟悉桥接模式有助于我们深入理解这些设计原则，也有助于我们形成正确的设计思想和培养良好的设计风格。  二、模式动机 在软件系统中，有些类由于其本身的固有特性，使得它有两个或多个变化维">
<meta name="twitter:image" content="https://ooo.0o0.ooo/2017/06/23/594d2c06d4678.jpg">
    
    
    
      <link rel="icon" type="image/x-icon" href="favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">SPACE-19</a></h1>
        <hr class="panel-cover__divider" />

        
        <p class="panel-cover__description">
          XD
        </p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">设计模式-桥接模式Bridge</h1>

    

    <div class="post-meta">
      <time datetime="2017-06-23" class="post-meta__date date">2017-06-23</time> 

      <span class="post-meta__tags tags">

          

          
             &#8226; 标签:
            <font class="tags">
              <a class="tags-link" href="/tags/设计模式/">设计模式</a>
            </font>
          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <h3 id="一、桥接模式-Bridge-Pattern"><a href="#一、桥接模式-Bridge-Pattern" class="headerlink" title="一、桥接模式(Bridge Pattern)"></a>一、桥接模式(Bridge Pattern)</h3><ul>
<li>桥接模式属于结构型模式。</li>
<li>桥接模式是一个非常实用的模式，<br>在桥接模式中体现了很多面向对象设计原则的思想，包括<code>单一职责原则</code>、<code>开闭原则</code>、<code>合成复用原则</code>、<code>里氏代换原则</code>、<code>依赖倒转原则</code>等。<br>熟悉桥接模式有助于我们深入理解这些设计原则，也有助于我们形成正确的设计思想和培养良好的设计风格。</li>
</ul>
<h3 id="二、模式动机"><a href="#二、模式动机" class="headerlink" title="二、模式动机"></a>二、模式动机</h3><ul>
<li>在软件系统中，有些类由于其本身的固有特性，使得它有两个或多个变化维度。<br>如一个既可以支持多种日志输出方式又可以支持多种操作系统的跨平台日志记录类。<br>对于这种多维度变化的系统，桥接模式提供了一套完整的解决方案，并且降低了系统的复杂性。</li>
<li>设想如果要绘制矩形、圆形、椭圆、正方形，且绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：<br>第一种设计方案是为每一种形状都提供一套各种颜色的版本（多继承）—–4*3=12<br>第二种设计方案是根据实际需要对形状和颜色进行组合（关联）——-4+3=7<br>很明显采用方案二类个数更少，且更方便于系统扩展，这种方法也就是桥接模式。</li>
<li>桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合（解耦），减少了代码编写量。</li>
</ul>
<h3 id="三、模式定义"><a href="#三、模式定义" class="headerlink" title="三、模式定义"></a>三、模式定义</h3><blockquote>
<p>桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。</p>
</blockquote>
<ul>
<li>桥接模式是一种很实用的结构型设计模式，如果软件系统中某个类存在两个独立变化的维度，通过该模式可以将这两个维度分离出来，使两者可以独立扩展，让系统更加符合“单一职责原则”。<br>与多层继承方案不同，它将两个独立变化的维度设计为两个独立的继承等级结构，并且在抽象层建立一个抽象关联，该关联关系类似一条连接两个独立继承结构的桥，故名桥接模式。</li>
<li>桥接模式用一种巧妙的方式处理多层继承存在的问题，用抽象关联取代了传统的多层继承，将类之间的静态继承关系转换为动态的对象组合关系，<br>使得系统更加灵活，并易于扩展，同时有效控制了系统中类的个数。</li>
</ul>
<h3 id="四、模式结构"><a href="#四、模式结构" class="headerlink" title="四、模式结构"></a>四、模式结构</h3><ul>
<li><p>桥接模式的结构与其名称一样，存在一条连接两个继承等级结构的桥。</p>
</li>
<li><p>桥接模式结构图<br><img src="https://ooo.0o0.ooo/2017/06/23/594d2c06d4678.jpg" alt="桥接模式结构图"></p>
</li>
<li><p>在桥接模式结构图中包含如下几个角色：</p>
</li>
</ul>
<ol>
<li>Abstraction（抽象类）：<br>用于定义抽象类的接口，它一般是抽象类而不是接口，<br>其中定义了一个Implementor（实现类接口）类型的对象并可以维护该对象，<br>它与Implementor之间具有关联关系，<br>它既可以包含抽象业务方法，也可以包含具体业务方法。</li>
<li>RefinedAbstraction（扩充抽象类）：<br>扩充由Abstraction定义的接口，通常情况下它不再是抽象类而是具体类，<br>它实现了在Abstraction中声明的抽象业务方法，在RefinedAbstraction中可以调用在Implementor中定义的业务方法。</li>
<li>Implementor（实现类接口）：<br>定义实现类的接口，这个接口不一定要与Abstraction的接口完全一致，事实上这两个接口可以完全不同，<br>一般而言，Implementor接口仅提供基本操作，而Abstraction定义的接口可能会做更多更复杂的操作。<br>Implementor接口对这些基本操作进行了声明，而具体实现交给其子类。<br>通过关联关系，在Abstraction中不仅拥有自己的方法，还可以调用到Implementor中定义的方法，使用关联关系来替代继承关系。</li>
<li>ConcreteImplementor（具体实现类）：<br>具体实现Implementor接口，在不同的ConcreteImplementor中提供基本操作的不同实现，<br>在程序运行时，ConcreteImplementor对象将替换其父类对象，提供给抽象类具体的业务操作方法。</li>
</ol>
<h3 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h3><ul>
<li>桥接模式可以从接口中分离实现功能，使得设计更具扩展性，客户端代码在调用方法时不需知道实现细节。<br>桥接模式减少子类的个数，使代码更简洁，生成的执行程序更小。</li>
<li>理解桥接模式，重点需要理解如何将<code>抽象化(Abstraction)</code>与<code>实现化(Implementation)</code>脱耦，使得二者可以独立地变化。<br>即理解三个关键词：<ol>
<li>抽象化：<br>在面向对象中，将对象的共同性质抽取出来形成类的过程即为抽象化的过程。 </li>
<li>实现化：<br>针对抽象化给出的具体实现，就是实现化。</li>
<li>脱耦：<br>脱耦就是将抽象化和实现化之间的耦合解脱开，将角色之间的继承关系改为关联关系，使它们可以相对独立地变化<br><img src="https://ooo.0o0.ooo/2017/06/23/594d32bee3e7a.jpg" alt="脱耦"></li>
</ol>
</li>
<li>在使用桥接模式时，首先应识别出一个类所具有的两个独立变化的维度，将它们设计为两个独立的继承等级结构，<br>为两个维度都提供抽象层，并建立抽象耦合。<br>通常情况下，我们将具有两个独立变化维度的类的一些普通业务方法和与之关系最密切的维度设计为“抽象类”层次结构（抽象部分），而将另一个维度设计为“实现类”层次结构（实现部分）。</li>
<li>例如：<br>对于毛笔而言，型号是其固有的维度，颜色是毛笔的另一个维度。<br>所以型号可认为是毛笔的抽象部分，而颜色是毛笔的实现部分。<br>如需要增加一种新型号的毛笔，只需扩展抽象部分，增加一个新的扩充抽象类；<br>如果需增加一种新的颜色，只需扩展实现部分，增加一个新的具体实现类。<br>扩展非常方便，无须修改已有代码，且不会导致类的数目增长过快。</li>
<li><p>在具体编码实现时，由于在桥接模式中存在两个独立变化的维度，为了使两者之间耦合度降低，<br>首先需要针对两个不同的维度提取抽象类和实现类接口，并建立一个抽象关联关系。<br>对于“实现部分”维度，典型的实现类接口代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//实现类接口</div><div class="line">interface Implementor </div><div class="line">&#123; </div><div class="line">  public void operationImpl();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在实现<code>Implementor接口</code>的子类中实现了在该接口中声明的方法，用于定义与该维度相对应的一些具体方法。<br>对于另一“抽象部分”维度而言，其典型的抽象类代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//抽象类代码</div><div class="line">abstract class Abstraction </div><div class="line">&#123;  </div><div class="line">    protected Implementor impl; //定义实现类接口对象  </div><div class="line">      </div><div class="line">    public void setImpl(Implementor impl) </div><div class="line">	&#123;  </div><div class="line">        this.impl=impl;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    public abstract void operation();  //声明抽象业务方法  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在抽象类Abstraction中定义了一个实现类接口类型的成员对象impl，再通过注入的方式给该对象赋值，<br>一般将该对象的可见性定义为protected，以便在其子类中访问Implementor的方法，<br>其子类一般称为扩充抽象类或细化抽象类(RefinedAbstraction)，典型的RefinedAbstraction类代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//扩充抽象类</div><div class="line">class RefinedAbstraction extends Abstraction </div><div class="line">&#123;  </div><div class="line">    public void operation() </div><div class="line">	&#123;  </div><div class="line">        //业务代码  </div><div class="line">        impl.operationImpl();  //调用实现类的方法  </div><div class="line">        //业务代码  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>对于客户端而言，可以针对两个维度的抽象层编程，<br>在程序运行时再动态确定两个维度的子类，动态组合对象，<br>将两个独立变化的维度完全解耦，以便能够灵活地扩充任一维度而对另一维度不造成任何影响。</p>
</li>
</ul>
<h3 id="六、知识点"><a href="#六、知识点" class="headerlink" title="六、知识点"></a>六、知识点</h3><ul>
<li><p>桥接模式的主要优点如下：<br>(1)<code>分离抽象接口及其实现部分</code>。桥接模式使用“对象间的关联关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自维度的变化，也就是说抽象和实现不再在同一个继承层次结构中，而是“子类化”它们，使它们各自都具有自己的子类，以便任何组合子类，从而获得多维度组合对象。<br>(2)在很多情况下，桥接模式可以取代多层继承方案，多层继承方案违背了“单一职责原则”，复用性较差，且类的个数非常多，桥接模式是比多层继承方案更好的解决方法，它极大减少了子类的个数。<br>(3)<code>桥接模式提高了系统的可扩充性</code>，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合“开闭原则”。<br>(4)<code>实现细节对客户透明</code>，可以对用户隐藏实现细节。</p>
</li>
<li><p>桥接模式的主要缺点如下：<br>(1)桥接模式的使用会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程。<br>(2)桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性，如何正确识别两个独立维度也需要一定的经验积累。</p>
</li>
<li><p>适用场景<br>(1)如果一个系统需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，通过桥接模式可以使它们在抽象层建立一个关联关系。<br>(2)“抽象部分”和“实现部分”可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。<br>(3)一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展。<br>(4)对于那些不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。</p>
</li>
<li><p>模式应用<br>(1) 模拟毛笔/画笔<br>(2) 跨平台<em>*</em>软件<br>(3) Java虚拟机<br>(4) Java桌面软件<br>(5) JDBC驱动程序</p>
</li>
</ul>
<h3 id="七、适配器模式与桥接模式的联用"><a href="#七、适配器模式与桥接模式的联用" class="headerlink" title="七、适配器模式与桥接模式的联用"></a>七、适配器模式与桥接模式的联用</h3><ul>
<li>在软件开发中，适配器模式通常可以与桥接模式联合使用。</li>
<li>适配器模式可以解决两个已有接口间不兼容问题，在这种情况下被适配的类往往是一个黑盒子，有时候我们不想也不能改变这个被适配的类，也不能控制其扩展。<br>适配器模式通常用于现有系统与第三方产品功能的集成，采用增加适配器的方式将第三方类集成到系统中。桥接模式则不同，用户可以通过接口继承或类继承的方式来对系统进行扩展。</li>
<li>桥接模式和适配器模式用于设计的不同阶段，桥接模式用于系统的初步设计，<br>对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；<br>而在初步设计完成之后，当发现系统与已有类无法协同工作时，可以采用适配器模式。<br>但有时候在设计初期也需要考虑适配器模式，特别是那些涉及到大量第三方应用接口的情况。</li>
<li>下面通过一个实例来说明适配器模式和桥接模式的联合使用：<br>在某系统的报表处理模块中，需要将报表显示和数据采集分开，<br>系统可以有多种报表显示方式也可以有多种数据采集方式，如可以从文本文件中读取数据，也可以从数据库中读取数据，还可以从Excel文件中获取数据。<br>如果需要从Excel文件中获取数据，则需要调用与Excel相关的API，而这个API是现有系统所不具备的，该API由厂商提供。使用适配器模式和桥接模式设计该模块。<br>在设计过程中，由于存在报表显示和数据采集两个独立变化的维度，<br>因此可以使用桥接模式进行初步设计；为了使用Excel相关的API来进行数据采集则需要使用适配器模式。<br>系统的完整设计中需要将两个模式联用，如下图所示：<br><img src="https://ooo.0o0.ooo/2017/06/24/594d4cea7ec64.jpg" alt="适配器模式与桥接模式的联用"></li>
</ul>
<h3 id="八、重要实例"><a href="#八、重要实例" class="headerlink" title="八、重要实例"></a>八、重要实例</h3><ul>
<li>要求：<br>如果需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Linux、Unix等）上播放多种格式的视频文件，<br>常见的视频格式包括MPEG、RMVB、AVI、WMV等。<br>现使用桥接模式设计该播放器，请根据类图编程实现该系统,并写出相应Java代码。</li>
<li><img src="https://ooo.0o0.ooo/2017/06/24/594d4e62980b2.jpg" alt="跨平台视频播放器类图"></li>
<li><p>解决代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line">//抽象播放器类：抽象类</div><div class="line">abstract class OperationSystemVersion</div><div class="line">&#123;</div><div class="line">	protected VideoFile vf;</div><div class="line">	public void setVideoFile(VideoFile vf)</div><div class="line">	&#123;</div><div class="line">		this.vf = vf;</div><div class="line">	&#125; </div><div class="line">	public abstract void play(String fileName);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//抽象视频文件类：抽象实现类</div><div class="line">interface VideoFile</div><div class="line">&#123;</div><div class="line">	public void decode(String osType, String fileName);</div><div class="line">&#125; </div><div class="line"></div><div class="line">//MPEG格式视频文件类：具体实现类</div><div class="line">class MPEGFile implements VideoFile</div><div class="line">&#123;</div><div class="line">	public void decode(String osType, String fileName)</div><div class="line">	&#123;</div><div class="line"> 		System.out.println(&quot;格式为MPEG的视频文件&quot; + fileName + &quot;在&quot; + osType + &quot;平台中解码播放。&quot;);</div><div class="line"> 	&#125;	</div><div class="line">&#125;</div><div class="line"></div><div class="line">//RMVB格式视频文件类：具体实现类</div><div class="line">class RMVBFile implements VideoFile</div><div class="line">&#123;</div><div class="line">	public void decode(String osType, String fileName)</div><div class="line">	&#123;</div><div class="line"> 		System.out.println(&quot;格式为RMVB的视频文件&quot; + fileName + &quot;在&quot; + osType + &quot;平台中解码播放。&quot;);</div><div class="line"> 	&#125;	</div><div class="line">&#125;</div><div class="line"></div><div class="line">//AVI格式视频文件类：具体实现类</div><div class="line">class AVIFile implements VideoFile</div><div class="line">&#123;</div><div class="line">	public void decode(String osType, String fileName)</div><div class="line">	&#123;</div><div class="line"> 		System.out.println(&quot;格式为AVI的视频文件&quot; + fileName + &quot;在&quot; + osType + &quot;平台中解码播放。&quot;);</div><div class="line"> 	&#125;	</div><div class="line">&#125;</div><div class="line"></div><div class="line">//WMV格式视频文件类：具体实现类</div><div class="line">class WMVFile implements VideoFile</div><div class="line">&#123;</div><div class="line">	public void decode(String osType, String fileName)</div><div class="line">	&#123;</div><div class="line"> 		System.out.println(&quot;格式为WMV的视频文件&quot; + fileName + &quot;在&quot; + osType + &quot;平台中解码播放。&quot;);</div><div class="line"> 	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//Window播放器类：扩充抽象类</div><div class="line">class WindowsVersion extends OperationSystemVersion</div><div class="line">&#123;</div><div class="line">	public void play(String fileName)</div><div class="line">	&#123;</div><div class="line">		vf.decode(&quot;Windows&quot;,fileName);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//Linux播放器类：扩充抽象类</div><div class="line">class LinuxVersion extends OperationSystemVersion</div><div class="line">&#123;</div><div class="line">	public void play(String fileName)</div><div class="line">	&#123;</div><div class="line">		vf.decode(&quot;Linux&quot;,fileName);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//Unix播放器类：扩充抽象类</div><div class="line">class UnixVersion extends OperationSystemVersion</div><div class="line">&#123;</div><div class="line">	public void play(String fileName)</div><div class="line">	&#123;</div><div class="line">		vf.decode(&quot;Unix&quot;,fileName);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//客户端测试类</div><div class="line">class Client</div><div class="line">&#123;</div><div class="line">	public static void main(String args[])</div><div class="line">	&#123;</div><div class="line">		VideoFile file;</div><div class="line">		OperationSystemVersion version;</div><div class="line">		file = new RMVBFile();</div><div class="line">		version = new WindowsVersion();</div><div class="line">		version.setVideoFile(file);</div><div class="line">		version.play(&quot;《让子弹飞》&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">格式为RMVB的视频文件《让子弹飞》在Windows平台中解码播放。</div></pre></td></tr></table></figure>
</li>
</ul>
<p>【参考】(作者：刘伟 <a href="http://blog.csdn.net/lovelion" target="_blank" rel="external">http://blog.csdn.net/lovelion</a>)</p>

  </section>

  
  
</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>

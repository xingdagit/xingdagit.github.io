<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      JS对象-基本包装类型对象 | SPACE-19 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
    

    <meta name="description" content="认识javascript 基本包装类型对象。 它是基本类型也是引用类型，所以叫基本包装类型。 为了方便操作基本类型值，ECMAScript提供了3个特殊的包装类型：Boolean、Number和String，以便于使用对象方法操作基本类型值（boolean、number、string）。 基本包装类型与其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。 引用类型和基本包装类型的主要区别">
<meta name="keywords" content="JS对象">
<meta property="og:type" content="article">
<meta property="og:title" content="JS对象-基本包装类型对象 | SPACE-19">
<meta property="og:url" content="http://yoursite.com/2017/06/16/JS对象-基本包装类型对象/index.html">
<meta property="og:site_name" content="SPACE-19">
<meta property="og:description" content="认识javascript 基本包装类型对象。 它是基本类型也是引用类型，所以叫基本包装类型。 为了方便操作基本类型值，ECMAScript提供了3个特殊的包装类型：Boolean、Number和String，以便于使用对象方法操作基本类型值（boolean、number、string）。 基本包装类型与其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。 引用类型和基本包装类型的主要区别">
<meta property="og:updated_time" content="2017-06-16T09:04:00.596Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JS对象-基本包装类型对象 | SPACE-19">
<meta name="twitter:description" content="认识javascript 基本包装类型对象。 它是基本类型也是引用类型，所以叫基本包装类型。 为了方便操作基本类型值，ECMAScript提供了3个特殊的包装类型：Boolean、Number和String，以便于使用对象方法操作基本类型值（boolean、number、string）。 基本包装类型与其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。 引用类型和基本包装类型的主要区别">
    
    
    
      <link rel="icon" type="image/x-icon" href="favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">SPACE-19</a></h1>
        <hr class="panel-cover__divider" />

        
        <p class="panel-cover__description">
          XD
        </p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">JS对象-基本包装类型对象</h1>

    

    <div class="post-meta">
      <time datetime="2017-06-16" class="post-meta__date date">2017-06-16</time> 

      <span class="post-meta__tags tags">

          

          
             &#8226; 标签:
            <font class="tags">
              <a class="tags-link" href="/tags/JS对象/">JS对象</a>
            </font>
          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <h3 id="认识javascript-基本包装类型对象。"><a href="#认识javascript-基本包装类型对象。" class="headerlink" title="认识javascript 基本包装类型对象。"></a>认识javascript 基本包装类型对象。</h3><ul>
<li>它是基本类型也是引用类型，所以叫基本包装类型。</li>
<li>为了方便操作基本类型值，ECMAScript提供了3个特殊的包装类型：<code>Boolean</code>、<code>Number</code>和<code>String</code>，以便于使用对象方法操作基本类型值（boolean、number、string）。</li>
<li>基本包装类型与其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。</li>
<li>引用类型和基本包装类型的主要区别是<code>对象的生存期</code>：<ol>
<li>使用new操作符创建的<code>引用类型</code>的实例在执行流离开当前作用域之前都一直保存在内存中。</li>
<li>而<code>基本包装类型</code>自动创建，并在代码执行后自动销毁实例。这意味着我们不能在运行时为基本类型值添加属性和方法。</li>
</ol>
</li>
<li>设计包装类型对象的最大目的：<br>除了使得JavaScript的“对象”涵盖所有的值，<br>还可以通过将<code>基本类型</code>的数据包装成<code>包装类型</code>，从而使得原始类型的值可以<code>调用</code>对应包装类型的特定方法，从而更方便地操作数据。</li>
<li><p>基本包装类型对象实例可以使用Object对象提供的原生方法，主要是<code>valueOf方法</code>和<code>toString方法</code>，但不同的类型又会有不同的效果。</p>
<ol>
<li><p><code>valueOf方法</code>返回包装对象实例对应的原始类型的值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">new Number(123).valueOf()     // 123 </div><div class="line">new String(&quot;abc&quot;).valueOf()   // &quot;abc&quot; </div><div class="line">new Boolean(&quot;true&quot;).valueOf() // true</div></pre></td></tr></table></figure>
</li>
<li><p><code>toString方法</code>返回实例对应的字符串形式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">new Number(123).toString()     // &quot;123&quot; </div><div class="line">new String(&quot;abc&quot;).toString()   // &quot;abc&quot; </div><div class="line">new Boolean(&quot;true&quot;).toString() // &quot;true&quot;</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h3 id="创建基本包装类型对象"><a href="#创建基本包装类型对象" class="headerlink" title="创建基本包装类型对象"></a>创建基本包装类型对象</h3><ul>
<li><p>基本类型的自动转换<br>即每当读取一个基本类型的值时，后台会创建一个对应包装类型的对象，从而将他们<code>包装</code>成了基本包装类型对象（类型转换了）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//以字符串为例：字符串有`string基本类型`和它的`基本包装类型`</div><div class="line">/***************例1***********************/</div><div class="line">&apos;abc&apos;.length // 3</div><div class="line">//上面代码中，abc是一个字符串，本身不是对象，不能调用length属性。</div><div class="line">//但JavaScript引擎自动将其转为包装对象，在这个对象上调用length属性。</div><div class="line">//调用结束后，这个临时对象就会被销毁。这就叫原始类型的自动转换。</div><div class="line"></div><div class="line">/***************例2***********************/</div><div class="line">var s1 = &quot;test string&quot;;  //s1为基本类型，本身没有定义任何的方法</div><div class="line">var s2 = s1.substring(4);//访问s1时，访问过程处于读取模式，也就是要从内存中读取这个字符串的值。</div><div class="line">//于是在读取字符串s1时，后台会完成以下处理：</div><div class="line">//创建一个String类型的临时对象实例-&gt;在实例上调用指定方法-&gt;销毁这个实例</div><div class="line">//相当于执行以下代码：</div><div class="line">var s1=new String(&quot;some text&quot;);</div><div class="line">var s2=s1.substring(2);</div><div class="line">s1=null;</div><div class="line"></div><div class="line">/****************例3************************/</div><div class="line">//且这个临时对象是只读的，无法修改。所以字符串无法添加新属性。</div><div class="line">var s1=&quot;test string&quot;;</div><div class="line">s1.color = &quot;red&quot;;  //添加新属性 </div><div class="line">s1.color //undefined（s1已经销毁）</div></pre></td></tr></table></figure>
</li>
<li><p>也可以用<code>new方法</code>(构造函数)创建<br><code>var b = new Boolean(true);</code> // true,生成了新的包装类型<br><code>var n = new Number(123);</code>   // 123,生成了新的包装类型<br><code>var s = new String(&#39;str&#39;);</code>// ‘str’,生成了新的包装类型</p>
</li>
<li><p>基本包装类型对象显示的值看起来不变，但类型已经变为<code>object</code>了(调用typeof会返回“object”)；<br>因此，对基本包装类型对象的值和基本类型值用<code>===</code>比较会返回<code>false</code>；<br>也因为这个原因少用基本包装类型对象(尤其是string类型)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var str = &apos;abc&apos;; </div><div class="line">str.length // 3 </div><div class="line">//相当于</div><div class="line">var strObj = new String(str) </div><div class="line">//得到String &#123;  0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot; &#125; </div><div class="line">strObj.length // 3</div></pre></td></tr></table></figure>
</li>
<li><p>若在创建基本包装类型对象时<code>没写new</code>，则<code>Number()、Boolean()和String()</code>等函数被当做普通的转换类型函数，<br>函数作用就变成：把<code>任意类型</code>的数据转换为<code>number、boolean和string原始类型</code>(注意不是其包装类型)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var n = Number(&apos;123&apos;); // 123，相当于parseInt()或parseFloat() </div><div class="line">typeof n; // &apos;number&apos; </div><div class="line"></div><div class="line">var b = Boolean(&apos;true&apos;); // true </div><div class="line">typeof b; // &apos;boolean&apos; </div><div class="line"></div><div class="line">var b2 = Boolean(&apos;false&apos;); // true，&apos;false&apos;字符串转换结果为true，因为它是非空字符串 </div><div class="line">var b3 = Boolean(&apos;&apos;); // false </div><div class="line"></div><div class="line">var s = String(123.45); // &apos;123.45&apos; </div><div class="line">typeof s; // &apos;string&apos;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h3><ul>
<li>Boolean类型是与<code>布尔值</code>对应的引用类型(基本包装类型)。</li>
<li><code>var falseObject = new Boolean(false);</code></li>
<li>重写<code>valueOf()方法</code>，返回基本类型值<code>true</code>和<code>false</code>；<br>重写<code>toString()方法</code>，返回字符串<code>&quot;true&quot;</code>和<code>&quot;false&quot;</code>.</li>
<li>基本类型与引用类型(基本包装类型)两者<code>布尔值</code>的区别：<ol>
<li>使用typeof测试<code>基本类型</code>返回<code>“boolean”</code>，对<code>引用类型(基本包装类型)</code>返回<code>“object”</code>。</li>
<li>由于<code>Boolean对象</code>是<code>Boolean类型(基本包装类型)</code>的实例，<br>所以用<code>instanceof操作符</code>测试<code>Boolean对象</code>会返回<code>true</code>，而测试<code>基本类型的布尔值</code>则返回<code>false</code>。</li>
</ol>
</li>
<li><p>可利用<code>Boolean()构造函数</code>将任意值转为布尔值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Boolean(undefined) // false </div><div class="line">Boolean(null)      // false </div><div class="line">Boolean(0)         // false </div><div class="line">Boolean(&apos;&apos;)        // false </div><div class="line">Boolean(NaN)       // false </div><div class="line">Boolean(false)     // false </div><div class="line"></div><div class="line">Boolean(1)         // true </div><div class="line">Boolean(&apos;false&apos;)   // true </div><div class="line">Boolean([])        // true </div><div class="line">Boolean(&#123;&#125;)        // true </div><div class="line">Boolean(function()&#123;&#125;) // true </div><div class="line">Boolean(/foo/)     // true</div><div class="line"></div><div class="line">//注意：所有基本包装类型的对象在转换为布尔类型时的值都为`true`</div><div class="line">new Boolean(xxx)   //都为true</div><div class="line">new Boolean(false) //也是true</div><div class="line">//要调用.valueOf()才返回原始值：</div><div class="line">new Boolean(false).valueOf() //false</div></pre></td></tr></table></figure>
<p>另外，在前面使用两个否运算符(即<code>!!</code>）也可以将任意值转为对应的布尔值。</p>
</li>
</ul>
<h3 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h3><ul>
<li>Number类型是与<code>数字值</code>对应的引用类型(基本包装类型)。</li>
<li><code>var numberObject = new Number(10);</code></li>
<li>重写了<code>valueOf()方法</code>，返回<code>基本类型数值</code>；<br>重写了<code>toString()方法</code>，返回<code>字符串形式的数值</code>.</li>
<li>将<code>数值</code>格式化为<code>字符串</code>的方法:<ol>
<li><code>toFixed()</code>：按照指定的小数点返回数值的字符串表示</li>
<li><code>toExponential()</code>：返回以指数表示法表示的数值的字符串形式</li>
<li><code>toPrecision()</code>：返回固定大小（fixed）格式，也可能返回指数（exponential）格式，具体规则看哪种格式最合适。</li>
</ol>
</li>
<li>基本类型与引用类型(基本包装类型)两者<code>数值</code>的区别：<br>由于<code>Number对象</code>是<code>Number类型(基本包装类型)</code>的实例，而<code>基本类型的数值</code>不是。<br>所以使用<code>typeof</code><br>测试<code>基本类型的数值</code>，始终会返回<code>“number”</code>，<br>测试<code>Number对象</code>，则会返回<code>“object”</code>。</li>
</ul>
<h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><ul>
<li>String类型是<code>字符串</code>的对象包装类型。</li>
<li><code>valueOf()方法</code>、<code>toString()方法</code>都返回对象所表示的基本字符串值。</li>
<li><code>var stringObject = new String(&quot;hello world&quot;);</code></li>
<li>字符处理方法：（两个方法都接受<code>字符位置</code>作为参数）<ol>
<li><code>charAt()</code>：以单字符字符串的形式返回给定位置的那个字符 </li>
<li><code>charCodeAt()</code>：以单字符字符串的形式返回给定位置的那个字符的字符编码 </li>
</ol>
</li>
<li>字符串操作方法：<ol>
<li><code>concat()</code>：将一或多个字符串拼接起来，返回拼接得到的新字符串 </li>
<li><code>slice()</code>、<code>substring()</code>：返回被操作字符的一个子字符串。<br>第一个参数指定子字符串的开始位置，第二个指定的是子字符串最后一个字符后面的位置 </li>
<li><code>sbustr()</code>：返回被操作字符的一个子字符串。<br>第一个参数指定子字符串的开始位置，第二个参数指定的是返回的字符个数。<br>如果没有给这些方法传递第二个参数，则将字符串的末尾作为结束位置。<br>这些方法都不会修改字符串本身的值，即对原始字符串没有影响。</li>
</ol>
</li>
<li>字符串位置方法：<br><code>indexOf()</code> 、<code>lastIndexOf()</code>：搜素给定的字符串，返回子字符串的位置（没有找到则返回-1）</li>
<li><code>trim()方法</code>：<br> 创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。<br> 对原始字符串没有影响。</li>
<li>字符串大小写转换方法：<code>toUpperCase()</code>、<code>toLowerCase()</code></li>
<li>字符串的模式匹配方法：<ol>
<li><code>match()</code>：接受一个参数（正则表达式或者RegExp对象）。<br>返回一个数组，在数组中，第一项是与整个模式匹配的字符串，其他项是与正则表达式中的捕获组匹配的字符串。 </li>
<li><code>search()</code>：接受一个参数（正则表达式或者RegExp对象）。<br>返回字符串中第一个匹配项的索引，没有找到则返回-1。始终是从字符串开头向后查找模式。 </li>
<li><code>replace()</code>：接受两个参数，第一个参数可以是一个RegExp对象或者是一个字符串（这个字符串不会转换为正则表达式），第二个参数可以是一个字符串或者一个函数</li>
<li><code>split()</code>：基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个RegExp对象。<br>split()方法可以接受可选的第二个参数，用于指定数组的大小，以确保返回的数组不会超过既定大小。 </li>
<li><code>localeCompare()</code>：按字母表顺序比较两个字符串。 排在字符串参数之后返回1，相等返回0，排在字符串参数之前返回-1</li>
<li><code>fromCharCode()</code>：接受一或多个字符编码，然后将他们转换成一个字符串。<br>和charCodeAt()执行相反的操作。</li>
</ol>
</li>
</ul>
<h3 id="使用基本包装类型对象需要遵守的几条规则："><a href="#使用基本包装类型对象需要遵守的几条规则：" class="headerlink" title="使用基本包装类型对象需要遵守的几条规则："></a>使用基本包装类型对象需要遵守的几条规则：</h3><ol>
<li>不要使用new Number()、new Boolean()、new String()创建包装对象（要用构造函数的方式创建/实例化对象）。<br>因为包装对象创建/实例化出来的是<code>对象类型</code>，而不是<code>Number/Boolean/String类型</code>。</li>
<li>转换类型：<br>1)转为<code>number</code>类型：用<code>parseInt()</code> / <code>parseFloat()</code>；<br>2)转为<code>boolean</code>类型：通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {…}；<br>3)转为<code>string</code>类型：用<code>String()</code> / <code>对象.toString()</code>。<br>  但要注意：<br>  第一，null和undefined伪对象没有toString()方法；<br>  第二，整数number类型使用toSting()方法要在数末尾多加一个点或用括号括住数：<br>  <code>789..toString();</code> 或 <code>(789).toString();</code></li>
<li>判断类型：<br>typeof操作符可判断：number / boolean / string / function / undefined；<br>判断Array：<code>Array.isArray(arr)；</code><br>判断null：<code>myVar === null；</code></li>
<li>判断存在性：<br>判断某个全局变量是否存在：用<code>typeof window.myVar === &#39;undefined&#39;；</code><br>判断函数内部某个变量是否存在：用<code>typeof myVar === &#39;undefined&#39;；</code> </li>
</ol>

  </section>

  
  
</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>

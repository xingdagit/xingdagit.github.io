<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      Java设计模式-常用面向对象七大原则 | SPACE-19 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
    

    <meta name="description" content="一、单一职责原则(Single Responsibility Principle,SRP)重要系数：★★★★☆  “There should never be more than one reason for a class to change”  定义：类的职责要单一，不能将太多的职责放在一个类中。 描述：即一个类只负责一项职责。（高内聚、低耦合） 作用：为了避免（解决）一个负责多个职责的类因其">
<meta name="keywords" content="设计模式">
<meta property="og:type" content="article">
<meta property="og:title" content="Java设计模式-常用面向对象七大原则 | SPACE-19">
<meta property="og:url" content="http://yoursite.com/2017/06/07/Java设计模式-常用面向对象七大原则/index.html">
<meta property="og:site_name" content="SPACE-19">
<meta property="og:description" content="一、单一职责原则(Single Responsibility Principle,SRP)重要系数：★★★★☆  “There should never be more than one reason for a class to change”  定义：类的职责要单一，不能将太多的职责放在一个类中。 描述：即一个类只负责一项职责。（高内聚、低耦合） 作用：为了避免（解决）一个负责多个职责的类因其">
<meta property="og:updated_time" content="2017-06-26T06:04:21.716Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java设计模式-常用面向对象七大原则 | SPACE-19">
<meta name="twitter:description" content="一、单一职责原则(Single Responsibility Principle,SRP)重要系数：★★★★☆  “There should never be more than one reason for a class to change”  定义：类的职责要单一，不能将太多的职责放在一个类中。 描述：即一个类只负责一项职责。（高内聚、低耦合） 作用：为了避免（解决）一个负责多个职责的类因其">
    
    
    
      <link rel="icon" type="image/x-icon" href="favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">SPACE-19</a></h1>
        <hr class="panel-cover__divider" />

        
        <p class="panel-cover__description">
          XD
        </p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">Java设计模式-常用面向对象七大原则</h1>

    

    <div class="post-meta">
      <time datetime="2017-06-07" class="post-meta__date date">2017-06-07</time> 

      <span class="post-meta__tags tags">

          

          
             &#8226; 标签:
            <font class="tags">
              <a class="tags-link" href="/tags/设计模式/">设计模式</a>
            </font>
          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <h3 id="一、单一职责原则-Single-Responsibility-Principle-SRP"><a href="#一、单一职责原则-Single-Responsibility-Principle-SRP" class="headerlink" title="一、单一职责原则(Single Responsibility Principle,SRP)"></a>一、单一职责原则(Single Responsibility Principle,SRP)</h3><p>重要系数：★★★★☆</p>
<blockquote>
<p>“There should never be more than one reason for a class to change”</p>
</blockquote>
<p><strong>定义：类的职责要单一，不能将太多的职责放在一个类中。</strong></p>
<p>描述：即一个类只负责一项职责。（高内聚、低耦合）</p>
<p>作用：为了避免（解决）一个负责多个职责的类因其中一个职责的改变而导致其他职责产生故障的问题。</p>
<p>优点： </p>
<ol>
<li>降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；</li>
<li>提高类的可读性和系统的可维护性； </li>
<li>变更引起的风险降低。变更是必然的，当修改一个功能时，如果单一职责原则遵守的好，可显著降低对其他功能的影响。 </li>
</ol>
<p>注意：</p>
<ol>
<li>单一职责原则不只是面向对象编程思想所特有的。只要是<code>模块化</code>的程序设计，都适用单一职责原则。</li>
<li>要学会避免因需求变更或其他原因而出现<code>职责扩散</code>的现象。在职责扩散到我们无法控制的程度之前，要立刻对代码进行重构。</li>
</ol>
<p>使用单一职责原则的设计模式：</p>
<ol>
<li></li>
</ol>
<h3 id="二、开闭原则-Open-Closed-Principle-OCP"><a href="#二、开闭原则-Open-Closed-Principle-OCP" class="headerlink" title="二、开闭原则(Open Closed Principle,OCP)"></a>二、开闭原则(Open Closed Principle,OCP)</h3><p>重要系数：★★★★★</p>
<blockquote>
<p>“Softeware entities like classes,modules and functions should be open for extension but closed for modifications.”</p>
</blockquote>
<p><strong>定义：一个软件实体如类、模块和函数应对扩展开放，但对修改关闭。</strong></p>
<p>描述：即当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化（在不修改一个软件实体的基础上去扩展其功能）。</p>
<p>作用：为软件实体的未来事物而制定的对现行开发设计进行约束。</p>
<p>优点： </p>
<ol>
<li>通过扩展已有的软件系统，可以提供新的行为，以满足对软件新的需求，使变化中的软件系统有一定的适应性和灵活性；</li>
<li>已有的软件模块，特别是最重要的抽象层模块不能再修改，这就使变化中的软件系统有一定的稳定性和延续性； </li>
<li>满足了可复用性与可维护性。 </li>
</ol>
<p>注意：</p>
<ol>
<li>面向对象设计中<code>最基础</code>的设计原则</li>
<li>开闭原则对扩展开放，对修改关闭，并不意味着不做任何修改，低层模块的变更，必然要有高层模块进行耦合，否则就是一个孤立无意义的代码片段了。</li>
<li>实现开闭原则关键在于<code>抽象化</code></li>
<li>对变化的封装包含两层含义：<br>第一，将相同的变化封装到一个接口或者抽象类中；<br>第二，将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中。</li>
</ol>
<p>使用开闭原则的设计例子：</p>
<ol>
<li></li>
</ol>
<h3 id="三、里氏代换原则-Liskov-Substitution-Principle-LSP"><a href="#三、里氏代换原则-Liskov-Substitution-Principle-LSP" class="headerlink" title="三、里氏代换原则(Liskov Substitution Principle,LSP)"></a>三、里氏代换原则(Liskov Substitution Principle,LSP)</h3><p>重要系数：★★★★☆</p>
<p><strong>严格定义：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P ，在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。</strong></p>
<p><strong>通俗定义：在软件系统中，一个可接受基类对象的地方必然可以接受一个子类对象。</strong></p>
<p>描述：在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常。反过来则不成立：如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。</p>
<p>注意：</p>
<ol>
<li>里氏代换原则是实现<code>开闭原则</code>的重要方式之一，也是<code>开闭原则的扩充</code>。</li>
<li>由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用<code>基类类型</code>来对对象进行<code>定义</code>，而在<code>运行时</code>再确定其<code>子类类型</code>，用子类对象来替换父类对象。</li>
<li>当使用<code>继承</code>时，要遵循里氏替换原则。<br>即子类可以扩展父类的功能，但不能改变父类原有的功能。<br>它包含以下4层含义：<br>1)子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。<br>2)子类中可以增加自己特有的方法。<br>3)当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。<br>4)当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li>
</ol>
<p>使用里氏代换原则的例子：</p>
<ol>
<li></li>
</ol>
<h3 id="四、依赖倒置原则-Dependence-Inversion-Principle，DIP"><a href="#四、依赖倒置原则-Dependence-Inversion-Principle，DIP" class="headerlink" title="四、依赖倒置原则(Dependence Inversion Principle，DIP)"></a>四、依赖倒置原则(Dependence Inversion Principle，DIP)</h3><p>重要系数：★★★★★</p>
<p><strong>定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。</strong></p>
<p>描述：要针对抽象层编程，而不要针对具体类编程。</p>
<p>作用：遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。</p>
<p>注意：</p>
<ol>
<li>依赖倒置原则的核心思想是<code>面向接口编程</code>。</li>
<li>修改类的依赖关系时，为避免因修改依赖类而给程序带来不必要的风险，将依赖类A修改为使用依赖接口I，被依赖类B和被依赖类C各自实现接口I：<br>即<code>类A</code>通过<code>接口I</code>间接与<code>类B</code>/<code>类C</code>发生联系（A 实例化 I，B和C implements I并实现其中方法）。</li>
<li>其实传递依赖关系有三种方式：除了前面说的<code>接口传递</code>，另外还有<code>构造方法传递</code>和<code>setter方法传递</code></li>
<li>根据依赖倒置原则，在实际编程中一般需做到以下3点：<br>1）低层模块尽量都要有抽象类或接口，或两者都有。<br>2）变量的声明类型尽量是抽象类或接口。<br>3）使用继承时遵循里氏替换原则。 </li>
</ol>
<p>使用依赖倒置原则的例子：</p>
<ol>
<li>TDD开发模式</li>
</ol>
<h3 id="五、接口隔离原则-Interface-Segregation-Principle-ISP"><a href="#五、接口隔离原则-Interface-Segregation-Principle-ISP" class="headerlink" title="五、接口隔离原则(Interface Segregation Principle, ISP)"></a>五、接口隔离原则(Interface Segregation Principle, ISP)</h3><p>重要系数：★★☆☆☆</p>
<p><strong>定义：使用多个专门的接口来取代一个统一的接口，即客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</strong></p>
<p>描述：为各个类建立专用的接口，而不要试图去建立一个过于庞大臃肿的接口供所有依赖它的类去调用。即当一个接口太大时，需要将它分割成一些更细小的接口。使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色。</p>
<p>优点：接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p>
<p>注意：</p>
<ol>
<li>在使用接口隔离原则时，需要注意控制接口的粒度：<br>1）接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；<br>2）接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。 </li>
<li>一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。</li>
</ol>
<p>使用接口隔离原则的例子：</p>
<ol>
<li></li>
</ol>
<h3 id="六、合成复用原则-Composition-Aggregate-Reuse-Principle-CARP"><a href="#六、合成复用原则-Composition-Aggregate-Reuse-Principle-CARP" class="headerlink" title="六、合成复用原则(Composition/Aggregate Reuse Principle, CARP)"></a>六、合成复用原则(Composition/Aggregate Reuse Principle, CARP)</h3><p>重要系数：★★★★☆</p>
<p><strong>定义：复用时要尽量使用关联关系（包括组合关系和聚合关系），少用继承。</strong></p>
<p>描述：新的对象应尽量多使用对象间的关联关系，尽量少使用甚至不使用继承关系来达到复用已有对象的目的。</p>
<p>优点：可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。</p>
<p>注意：</p>
<ol>
<li>尽量少用继承来进行复用的主要原因在于继承复用会<code>破坏系统的封装性</code>，滥用继承也可能会增加系统构建和维护的难度以及系统的复杂度。 </li>
<li>因为<code>继承</code>会将基类的实现细节<code>暴露</code>给子类，由于基类的内部细节通常对子类来说是<code>可见的</code>，这种复用称为<code>“白箱”复用</code>。<br>对于这种复用，如果基类发生改变，那么子类的实现也不得不发生改变。</li>
<li>由于<code>组合或聚合关系</code>可以将已有的对象（即成员对象）纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象<code>不可见</code>，这种复用称为<code>“黑箱”复用</code>。<br>对于这种复用，成员对象的变化对新对象的影响不大。</li>
<li>一般而言，<br>如果两个类之间是<code>Has-A</code>的关系（某一个角色具有某一项责任），应使用<code>组合或聚合</code>;<br>如果两个类之间是<code>Is-A</code>的关系(一个类是另一个类的”一种”)，可使用<code>继承</code>。</li>
</ol>
<p>使用合成复用原则的例子：</p>
<ol>
<li></li>
</ol>
<h3 id="七、迪米特原则（Law-of-Demeter-LoD）-最少知识原则-LeastKnowledge-Principle-LKP"><a href="#七、迪米特原则（Law-of-Demeter-LoD）-最少知识原则-LeastKnowledge-Principle-LKP" class="headerlink" title="七、迪米特原则（Law of  Demeter, LoD）/最少知识原则(LeastKnowledge Principle, LKP)"></a>七、迪米特原则（Law of  Demeter, LoD）/最少知识原则(LeastKnowledge Principle, LKP)</h3><p>重要系数：★★★☆☆</p>
<blockquote>
<p>不要和“陌生人”说话、只与你的直接朋友通信</p>
</blockquote>
<p><strong>定义：一个软件实体应尽可能少地与其他实体发生相互作用。</strong></p>
<p>描述：如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，而是通过引入一个第三者发生间接交互。</p>
<p>优点：因类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。所以遵循迪米特原则可以尽量降低类与类之间的耦合，使类与类之间保持松散的耦合关系。。</p>
<p>注意：</p>
<ol>
<li>每个对象都会与其他对象有耦合关系（耦合的方式很多，依赖、关联、组合、聚合等）。<br>只要两个对象之间有<code>耦合关系</code>，我们就说这两个对象之间是<code>朋友关系</code>。<br>我们称<br>出现在<code>成员变量、方法参数、方法返回值</code>中的类为<code>直接的朋友</code>，<br>出现在<code>局部变量</code>中的类则<code>不是直接的朋友</code>。<br>所以，陌生的类最好不要作为局部变量的形式出现在类的内部。</li>
<li>使用迪米特原则，通常需要利用<code>中介者</code>。<br>但过分的使用会产生大量的中介和传递类，导致系统复杂度变大。<br>所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。</li>
</ol>
<p>使用迪米特原则的例子：<br>1. </p>

  </section>

  
  
</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      JS-AJAX | SPACE-19 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
    

    <meta name="description" content="AJAX 全称：Asynchronous JavaScript and XML，即用JavaScript执行异步网络请求。 Web的运作原理为一次HTTP请求对应一个页面。如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面。这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。即在首次加载">
<meta name="keywords" content="JS">
<meta property="og:type" content="article">
<meta property="og:title" content="JS-AJAX | SPACE-19">
<meta property="og:url" content="http://yoursite.com/2017/06/04/JS-AJAX/index.html">
<meta property="og:site_name" content="SPACE-19">
<meta property="og:description" content="AJAX 全称：Asynchronous JavaScript and XML，即用JavaScript执行异步网络请求。 Web的运作原理为一次HTTP请求对应一个页面。如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面。这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。即在首次加载">
<meta property="og:image" content="http://www.liaoxuefeng.com/files/attachments/00143640805071744d58164a40e42ef92b9973824451595000/l">
<meta property="og:image" content="http://www.liaoxuefeng.com/files/attachments/001436512391628944d5da9a5654a35b0ace38246f30b9c000/l">
<meta property="og:updated_time" content="2017-06-04T08:42:21.751Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JS-AJAX | SPACE-19">
<meta name="twitter:description" content="AJAX 全称：Asynchronous JavaScript and XML，即用JavaScript执行异步网络请求。 Web的运作原理为一次HTTP请求对应一个页面。如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面。这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。即在首次加载">
<meta name="twitter:image" content="http://www.liaoxuefeng.com/files/attachments/00143640805071744d58164a40e42ef92b9973824451595000/l">
    
    
    
      <link rel="icon" type="image/x-icon" href="favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">SPACE-19</a></h1>
        <hr class="panel-cover__divider" />

        
        <p class="panel-cover__description">
          XD
        </p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">JS-AJAX</h1>

    

    <div class="post-meta">
      <time datetime="2017-06-04" class="post-meta__date date">2017-06-04</time> 

      <span class="post-meta__tags tags">

          

          
             &#8226; 标签:
            <font class="tags">
              <a class="tags-link" href="/tags/JS/">JS</a>
            </font>
          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><ul>
<li>全称：Asynchronous JavaScript and XML，即用JavaScript执行<code>异步网络请求</code>。</li>
<li>Web的运作原理为一次HTTP请求对应一个页面。如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面。这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。即在首次加载后，剩下的所有数据都依赖于AJAX来更新。 </li>
<li>AJAX请求是异步执行的，也就是说，要通过回调函数获得响应。</li>
<li>在现代浏览器上写AJAX主要依靠<code>XMLHttpRequest</code>对象(对于低版本的IE，需要换一个ActiveXObject对象)。</li>
<li><code>XMLHttpRequest</code>对象的<code>open()</code>方法有3个参数:<br>第一个参数指定是<code>GET</code>(不需参数)还是<code>POST</code>(需要把body部分以字符串或FormData对象传进去)；<br>第二个参数指定URL地址；<br>第三个参数指定是否使用异步，默认是true，所以一般省略不写（千万不要指定为<code>false</code>，否则浏览器将停止响应，直到AJAX请求完成。如果这个请求耗时10秒，那么10秒内你会发现浏览器处于“假死”状态）。</li>
<li><p>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">function success(text) &#123;</div><div class="line">    var textarea = document.getElementById(&apos;test-response-text&apos;);</div><div class="line">    textarea.value = text;</div><div class="line">&#125;</div><div class="line">function fail(code) &#123;</div><div class="line">    var textarea = document.getElementById(&apos;test-response-text&apos;);</div><div class="line">    textarea.value = &apos;Error code: &apos; + code;</div><div class="line">&#125;</div><div class="line">var request;</div><div class="line">if (window.XMLHttpRequest) //注意不要根据浏览器的`navigator.userAgent`来检测浏览器是否支持某个JavaScript特性</div><div class="line">&#123;</div><div class="line">  request = new XMLHttpRequest();// 新建XMLHttpRequest对象(现代浏览器)</div><div class="line">&#125; </div><div class="line">else &#123;</div><div class="line">  request = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;); // 新建ActiveXObject对象(低版本的IE)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//设置onreadystatechange的回调函数(状态发生变化时，函数被回调)</div><div class="line">request.onreadystatechange = function ()</div><div class="line">&#123;</div><div class="line">  if (request.readyState === 4) // 成功完成</div><div class="line">  &#123; </div><div class="line">      if (request.status === 200) // 判断响应结果</div><div class="line">      &#123;</div><div class="line">          return success(request.responseText); // 成功，通过responseText拿到响应的文本(为服务端输出的内容)</div><div class="line">      &#125;</div><div class="line">      else </div><div class="line">      &#123;</div><div class="line">          return fail(request.status);// 失败，根据响应码判断失败原因:</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  else &#123;</div><div class="line">     // HTTP请求还在继续...</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">request.open(&apos;GET&apos;, &apos;/api/categories&apos;); //指定GET方式， URL使用的是相对路径</div><div class="line">request.send(); // 发送请求</div><div class="line">alert(&apos;请求已发送，请等待响应...&apos;);</div></pre></td></tr></table></figure>
</li>
<li><p>上面代码的URL使用的是相对路径。如果改为<code>&#39;http://www.sina.com.cn/&#39;</code>再运行肯定报错。在Chrome的控制台里，还可以看到错误信息。这是因为浏览器的同源策略导致的。</p>
</li>
<li>默认情况下，JavaScript在发送AJAX请求时，URL的域名必须和当前页面(域名、协议、端口号)完全一致。</li>
<li>当用JavaScript请求外域（其他网站）的URL时的方法：<ol>
<li>通过Flash插件发送HTTP请求，这种方式可以绕过浏览器的安全限制，但必须安装Flash，并且跟Flash交互，而且Flash用起来麻烦；</li>
<li>通过在同源域名下架设一个代理服务器来转发，JavaScript负责把请求发送到代理服务器：<code>&#39;/proxy?url=http://www.sina.com.cn&#39;</code>，代理服务器再把结果返回，这样就遵守了浏览器的同源策略。这种方式麻烦之处在于需要服务器端额外做开发；</li>
<li>这种方式称为<code>JSONP</code>，它有个限制，只能用GET请求，并且要求返回JavaScript。这种方式跨域实际上是利用了浏览器允许跨域引用JavaScript资源。</li>
</ol>
</li>
</ul>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><ol>
<li>全称Cross-Origin Resource Sharing，是HTML5规范定义的跨域策略。</li>
<li><code>Origin</code>表示本域，即浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查<code>Access-Control-Allow-Origin</code>是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。</li>
<li>实例：假设本域是<code>my.com</code>，外域是<code>sina.com</code>，只要响应头<code>Access-Control-Allow-Origin</code>为<code>http://my.com</code>或<code>*</code>，本次请求就可以成功。如下图所示：<br><img src="http://www.liaoxuefeng.com/files/attachments/00143640805071744d58164a40e42ef92b9973824451595000/l" alt="CORS图示"></li>
<li>可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的<code>Access-Control-Allow-Origin</code>，决定权始终在对方手中。</li>
<li>这种跨域请求，称之为“简单请求”。简单请求包括<code>GET</code>、<code>HEAD</code>和<code>POST</code>（POST的Content-Type类型仅限<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>和<code>text/plain</code>），并且不能出现任何自定义头（如<code>X-Custom: 12345</code>），通常能满足90%的需求。</li>
<li>在引用外域资源时，除了JavaScript和CSS外，都要验证<code>CORS</code>。</li>
</ol>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><ul>
<li>JavaScript所有代码都是单线程执行的，由于这个“缺陷”，JavaScript的所有网络操作、浏览器事件，都必须是异步执行。</li>
<li>异步执行可以用回调函数实现：一般是在将来的某个时间点触发一个函数调用。</li>
<li>AJAX就是典型的异步操作，但上述的AJAX代码把回调函数<code>success(request.responseText)</code>和<code>fail(request.status)</code>写到一个AJAX操作里不但不美观也不利于代码复用。</li>
<li>于是在ES6中统一规范一个由浏览器直接支持的Promise对象，用于在将来某个时候调用相应函数。</li>
<li>使用Promise对象可使代码先统一执行AJAX逻辑，不关心(函数)如何处理结果，然后根据结果是成功还是失败，在将来的某个时候调用<code>success</code>函数/<code>fail</code>函数。</li>
<li><p>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&apos;use strict&apos;;</div><div class="line">// 先清除log:</div><div class="line">var logging = document.getElementById(&apos;test-promise-log&apos;);</div><div class="line">while (logging.children.length &gt; 1) &#123;</div><div class="line">    logging.removeChild(logging.children[logging.children.length - 1]);</div><div class="line">&#125;</div><div class="line">// 再输出log到页面:</div><div class="line">function log(s) &#123;</div><div class="line">  var p = document.createElement(&apos;p&apos;);</div><div class="line">  p.innerHTML = s;</div><div class="line">  logging.appendChild(p);</div><div class="line">&#125;</div><div class="line">//定义Promise对象</div><div class="line">//function函数在内部异步执行，只关心自身的逻辑，并不关心resolve和reject函数具体如何处理结果</div><div class="line">new Promise(function (resolve, reject) //两个参数都是函数，成功或失败时分别调用</div><div class="line">&#123;</div><div class="line">  log(&apos;start new Promise...&apos;);</div><div class="line">  var timeOut = Math.random() * 2; //生成一个0-2之间的随机数</div><div class="line">  log(&apos;set timeout to: &apos; + timeOut + &apos; seconds.&apos;);</div><div class="line">  setTimeout(function () </div><div class="line">  &#123;</div><div class="line">      if (timeOut &lt; 1) &#123;  //如小于1则等待一段时间后调用resolve函数并返回成功</div><div class="line">          log(&apos;call resolve()...&apos;);</div><div class="line">          resolve(&apos;200 OK&apos;);</div><div class="line">      &#125;</div><div class="line">      else &#123;  //失败则调用reject函数</div><div class="line">          log(&apos;call reject()...&apos;);</div><div class="line">          reject(&apos;timeout in &apos; + timeOut + &apos; seconds.&apos;);</div><div class="line">      &#125;</div><div class="line">  &#125;, timeOut * 1000);</div><div class="line">&#125;).then(function (r) &#123;  //如执行成功</div><div class="line">  log(&apos;Done: &apos; + r);  //获得响应内容</div><div class="line">&#125;).catch(function (reason) &#123;  //如执行失败</div><div class="line">  log(&apos;Failed: &apos; + reason); //获得响应代码</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>可见Promise最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离。<br><img src="http://www.liaoxuefeng.com/files/attachments/001436512391628944d5da9a5654a35b0ace38246f30b9c000/l" alt="*"></p>
</li>
<li><p>setTimeout函数可看成一个模拟网络等异步执行的函数。下面把上述AJAX异步执行函数转换为Promise对象来简化异步处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&apos;use strict&apos;;</div><div class="line">function ajax(method, url, data) // ajax函数将返回Promise对象</div><div class="line">&#123;</div><div class="line">  var request = new XMLHttpRequest();</div><div class="line">  return new Promise(function (resolve, reject) </div><div class="line">  &#123;</div><div class="line">      request.onreadystatechange = function () &#123;</div><div class="line">          if (request.readyState === 4) </div><div class="line">          &#123;</div><div class="line">              if (request.status === 200) &#123;</div><div class="line">                  resolve(request.responseText);</div><div class="line">              &#125; </div><div class="line">              else &#123;</div><div class="line">                  reject(request.status);</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;;</div><div class="line">      request.open(method, url);</div><div class="line">      request.send(data);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var log = document.getElementById(&apos;test-promise-ajax-result&apos;);</div><div class="line">var p = ajax(&apos;GET&apos;, &apos;/api/categories&apos;);</div><div class="line">p.then(function (text) &#123; // 如果AJAX成功，获得响应内容</div><div class="line">  log.innerText = text;</div><div class="line">&#125;).catch(function (status) &#123; // 如果AJAX失败，获得响应代码</div><div class="line">  log.innerText = &apos;ERROR: &apos; + status;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>Promise还可以做更多的事情。比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。要串行执行这样的异步任务，不用Promise则需要写一层一层的嵌套代码。有了Promise，我们只需要简单地写：<br><code>job1.then(job2).then(job3).catch(handleError);</code> //其中，job1、job2和job3都是Promise对象</p>
</li>
<li><p>实例：串行执行一系列需要异步计算获得结果的任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function multiply(input)   // 0.5秒后返回input*input的计算结果</div><div class="line">&#123;</div><div class="line">    return new Promise(function (resolve, reject) &#123;</div><div class="line">        log(&apos;calculating &apos; + input + &apos; x &apos; + input + &apos;...&apos;);</div><div class="line">        setTimeout(resolve, 500, input * input);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">function add(input) 0.5秒后返回input+input的计算结果</div><div class="line">&#123;</div><div class="line">    return new Promise(function (resolve, reject) &#123;</div><div class="line">        log(&apos;calculating &apos; + input + &apos; + &apos; + input + &apos;...&apos;);</div><div class="line">        setTimeout(resolve, 500, input + input);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var p = new Promise(function (resolve, reject) &#123;</div><div class="line">      log(&apos;start new Promise...&apos;);</div><div class="line">      resolve(123);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p.then(multiply)</div><div class="line">   .then(add)</div><div class="line">   .then(multiply)</div><div class="line">   .then(add)</div><div class="line">   .then(function (result) &#123;  log(&apos;Got value: &apos; + result);  &#125; );</div></pre></td></tr></table></figure>
</li>
<li><p>除了串行执行若干异步任务外，Promise还可以并行执行异步任务。</p>
</li>
</ul>

  </section>

  
  
</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>

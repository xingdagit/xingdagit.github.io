<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      设计模式-单例模式Singleton | SPACE-19 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
    

    <meta name="description" content="一、单例模式(Singleton Pattern) 单例模式属于创建型模式。 单例模式是所有设计模式中结构最为简单的模式，它只包含一个类，即单例类。 实例具有唯一性。  二、模式动机 对于系统中的某些类来说，只有一个实例很重要。 如一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；如一个系统只能有一个文件系统；如一个系统只能有一个计时工具或ID（序号）生成器；如在Windows系统中始">
<meta name="keywords" content="设计模式">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式-单例模式Singleton | SPACE-19">
<meta property="og:url" content="http://yoursite.com/2017/06/22/设计模式-单例模式Singleton/index.html">
<meta property="og:site_name" content="SPACE-19">
<meta property="og:description" content="一、单例模式(Singleton Pattern) 单例模式属于创建型模式。 单例模式是所有设计模式中结构最为简单的模式，它只包含一个类，即单例类。 实例具有唯一性。  二、模式动机 对于系统中的某些类来说，只有一个实例很重要。 如一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；如一个系统只能有一个文件系统；如一个系统只能有一个计时工具或ID（序号）生成器；如在Windows系统中始">
<meta property="og:image" content="https://ooo.0o0.ooo/2017/06/22/594bd450b7650.jpg">
<meta property="og:image" content="https://ooo.0o0.ooo/2017/06/22/594be57503d30.jpg">
<meta property="og:image" content="https://ooo.0o0.ooo/2017/06/22/594be48c92429.jpg">
<meta property="og:image" content="https://ooo.0o0.ooo/2017/06/22/594bdace5fed0.jpg">
<meta property="og:updated_time" content="2017-06-22T16:22:25.553Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="设计模式-单例模式Singleton | SPACE-19">
<meta name="twitter:description" content="一、单例模式(Singleton Pattern) 单例模式属于创建型模式。 单例模式是所有设计模式中结构最为简单的模式，它只包含一个类，即单例类。 实例具有唯一性。  二、模式动机 对于系统中的某些类来说，只有一个实例很重要。 如一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；如一个系统只能有一个文件系统；如一个系统只能有一个计时工具或ID（序号）生成器；如在Windows系统中始">
<meta name="twitter:image" content="https://ooo.0o0.ooo/2017/06/22/594bd450b7650.jpg">
    
    
    
      <link rel="icon" type="image/x-icon" href="favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">SPACE-19</a></h1>
        <hr class="panel-cover__divider" />

        
        <p class="panel-cover__description">
          XD
        </p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">设计模式-单例模式Singleton</h1>

    

    <div class="post-meta">
      <time datetime="2017-06-22" class="post-meta__date date">2017-06-22</time> 

      <span class="post-meta__tags tags">

          

          
             &#8226; 标签:
            <font class="tags">
              <a class="tags-link" href="/tags/设计模式/">设计模式</a>
            </font>
          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <h3 id="一、单例模式-Singleton-Pattern"><a href="#一、单例模式-Singleton-Pattern" class="headerlink" title="一、单例模式(Singleton Pattern)"></a>一、单例模式(Singleton Pattern)</h3><ul>
<li>单例模式属于创建型模式。</li>
<li>单例模式是所有设计模式中结构最为简单的模式，它只包含一个类，即单例类。</li>
<li>实例具有唯一性。</li>
</ul>
<h3 id="二、模式动机"><a href="#二、模式动机" class="headerlink" title="二、模式动机"></a>二、模式动机</h3><ul>
<li>对于系统中的某些类来说，只有一个实例很重要。</li>
<li>如一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；<br>如一个系统只能有一个文件系统；<br>如一个系统只能有一个计时工具或ID（序号）生成器；<br>如在Windows系统中始终只能弹出一个任务管理器窗口，也就是说在一个Windows系统中，任务管理器存在唯一性。</li>
<li>以Windows系统的任务管理器窗口为例，<br>若不使用机制对窗口对象进行唯一化，将弹出多个重复的窗口对象，浪费内存资源；<br>若弹出的多个任务管理器不重复，意味着某瞬间系统有多个状态，这与实际不符；<br>因此，有时候确保系统中的某个对象的唯一性即一个类只能有一个实例很重要。</li>
<li>为节约系统资源，有时需确保系统中某个类只有唯一一个实例，那么如何保证一个类只有一个实例并且这个实例易于被访问呢？<br>1.定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。<br>2.一个更好的解决办法是让<code>类自身负责保存它的唯一实例</code>。<br>当其唯一实例创建成功后，这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法，所有的操作都只能基于这个唯一实例。这就是单例模式的动机所在。</li>
</ul>
<h3 id="三、模式定义"><a href="#三、模式定义" class="headerlink" title="三、模式定义"></a>三、模式定义</h3><blockquote>
<p>单例模式(Singleton Pattern)：单例模式确保<code>某一个类只有一个实例</code>，而且<code>自行实例化</code>并<code>向整个系统提供这个实例</code>，这个类称为单例类，它提供全局访问的方法。</p>
</blockquote>
<ul>
<li>单例模式有三个要点<br>（1）<code>某个类只能有一个实例</code>；<br>（2）<code>它必须自行创建这个实例</code>；<br>（3）<code>它必须自行向整个系统提供这个实例</code>。</li>
</ul>
<h3 id="四、模式结构"><a href="#四、模式结构" class="headerlink" title="四、模式结构"></a>四、模式结构</h3><ul>
<li><p>单例模式结构图<br><img src="https://ooo.0o0.ooo/2017/06/22/594bd450b7650.jpg" alt="单例模式结构图"></p>
</li>
<li><p>单例模式结构图中只包含一个单例角色：<br>Singleton（单例）：<br>在单例类的内部实现只生成一个实例，<br>同时它提供一个静态的getInstance()工厂方法，让客户可以访问它的唯一实例；<br>为了防止在外部对其实例化，将其构造函数设计为私有；<br>在单例类内部定义了一个Singleton类型的静态对象，作为外部共享的唯一实例。</p>
</li>
</ul>
<h3 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h3><ul>
<li>单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。</li>
<li>单例模式包含的角色只有一个，就是单例类—Singleton。</li>
<li>单例类拥有一个私有构造函数，确保用户无法通过new关键字直接实例化它。<br>除此之外，该模式中包含一个静态私有成员变量与静态公有的工厂方法，该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。</li>
<li><p>一般情况下单例模式的实现代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Singleton </div><div class="line">&#123; </div><div class="line">   private static Singleton instance=null; //静态私有成员变量 </div><div class="line">   </div><div class="line">   private Singleton()&#123; &#125; //私有构造函数 </div><div class="line">   </div><div class="line">   public static Singleton getInstance( ) //静态公有工厂方法，返回唯一实例 </div><div class="line">   &#123; </div><div class="line">      if(instance==null) </div><div class="line">	    instance=new Singleton(); //实例化后存储在静态成员变量中，以确保只有一个实例被创建</div><div class="line">	  return instance; </div><div class="line">   &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>总之，在单例模式的实现过程中，需要注意如下三点：<br>（1）单例类的构造函数为私有；<br>（2）提供一个自身的静态私有成员变量；<br>（3）提供一个公有的静态工厂方法。</p>
</li>
</ul>
<h3 id="六、知识点"><a href="#六、知识点" class="headerlink" title="六、知识点"></a>六、知识点</h3><ul>
<li><p>优点：<br>(1) 单例模式提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。<br>(2) 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。<br>(3) 允许可变数目的实例。基于单例模式我们可以进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例，既节省系统资源，又解决了单例单例对象共享过多有损性能的问题。</p>
</li>
<li><p>缺点：<br>(1) 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。<br>(2) 单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。<br>(3) 现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的共享对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致共享的单例对象状态的丢失。</p>
</li>
<li><p>适用场景<br>(1) 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。<br>(2) 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</p>
</li>
<li><p>模式应用<br>(1) Window系统任务管理器<br>(2) 分配身份证号码<br>(3) 打印池的设计<br>(4) Java语言类库JDK中有很多单例模式的应用实例(如java.lang.Runtime类)<br>(5) 数据库表中须保证主键唯一性的主键编号生成器<br>(6) Java EE框架 Spring 通过单例模式创建类的实例</p>
</li>
</ul>
<h3 id="七、关于饿汉式单例与懒汉式单例"><a href="#七、关于饿汉式单例与懒汉式单例" class="headerlink" title="七、关于饿汉式单例与懒汉式单例"></a>七、关于饿汉式单例与懒汉式单例</h3><ul>
<li><p>饿汉式单例类<br>饿汉式单例类是在Java语言中实现起来最为方便的单例类，其结构图如下：<br><img src="https://ooo.0o0.ooo/2017/06/22/594be57503d30.jpg" alt="饿汉式单例类结构图"><br>  从图中可看出，由于在定义静态变量的时候实例化单例类，因此在类加载的时候就已经创建了单例对象，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class EagerSingleton &#123;   </div><div class="line">    private static final EagerSingleton instance = new EagerSingleton();   </div><div class="line">    private EagerSingleton() &#123; &#125;   </div><div class="line">  </div><div class="line">    public static EagerSingleton getInstance() &#123;  </div><div class="line">        return instance;   </div><div class="line">    &#125;     </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  当类被加载时，静态变量instance会被初始化，此时类的私有构造函数会被调用，单例类的唯一实例将被创建。<br>  使用饿汉式单例可确保单例对象的唯一性，不会出现创建多个单例对象的情况。</p>
</li>
<li><p>懒汉式单例类<br>懒汉式单例类的构造函数也是私有的（这点与饿汉式单例类相同）<br>但懒汉式单例类<code>在第一次被引用时就将自己实例化</code>，而在其被加载时(之后)不会将自己实例化<br><img src="https://ooo.0o0.ooo/2017/06/22/594be48c92429.jpg" alt="懒汉式单例类结构图"><br>  从图中可看出，懒汉式单例在第一次调用getInstance()方法时实例化，在类加载时并不自行实例化，<br>这种技术又称为延迟加载(Lazy Load)技术，即需要的时候再加载实例。<br>  为了避免多个线程同时调用getInstance()方法，我们可以使用<code>关键字synchronized</code>，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class LazySingleton </div><div class="line">&#123;   </div><div class="line">    private static LazySingleton instance = null;   </div><div class="line">  </div><div class="line">    private LazySingleton() &#123; &#125;   </div><div class="line">  </div><div class="line">    synchronized public static LazySingleton getInstance() </div><div class="line">	&#123;   </div><div class="line">        if (instance == null) &#123;  </div><div class="line">            instance = new LazySingleton();   </div><div class="line">        &#125;  </div><div class="line">        return instance;   </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>该懒汉式单例类在getInstance()方法前面增加了关键字synchronized进行线程锁，以处理多个线程同时访问的问题。<br>但是，上述代码虽然解决了线程安全问题，但是每次调用getInstance()时都需要进行线程锁定判断，在多线程高并发访问环境中，将会导致系统性能大大降低。<br>    如何既解决线程安全问题又不影响系统性能呢？我们继续对懒汉式单例进行改进。<br>    事实上，我们无须对整个getInstance()方法进行锁定，只需对其中的代码“instance = new LazySingleton();”进行锁定即可。因此getInstance()方法可以进行如下改进：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static LazySingleton getInstance() </div><div class="line">&#123;   </div><div class="line">    if (instance == null) </div><div class="line">	&#123;  </div><div class="line">        synchronized (LazySingleton.class) &#123;  </div><div class="line">            instance = new LazySingleton();   </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    return instance;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>问题貌似得以解决，事实并非如此。如果使用以上代码来实现单例，还是会存在单例对象不唯一。<br>原因如下：<br>    假如在某一瞬间线程A和线程B都在调用getInstance()方法，此时instance对象为null值，均能通过instance == null的判断。<br>    由于实现了synchronized加锁机制，线程A进入synchronized锁定的代码中执行实例创建代码，线程B处于排队等待状态，必须等待线程A执行完毕后才可以进入synchronized锁定代码。<br>    但当A执行完毕时，线程B并不知道实例已经创建，将继续创建新的实例，导致产生多个单例对象，违背单例模式的设计思想。<br>因此需要进行进一步改进，在synchronized中再进行一次(instance == null)判断，这种方式称为双重检查锁定(Double-Check Locking)。<br>使用双重检查锁定实现的懒汉式单例类完整代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class LazySingleton </div><div class="line">&#123;   </div><div class="line">    private volatile static LazySingleton instance = null;   </div><div class="line">  </div><div class="line">    private LazySingleton() &#123; &#125;   </div><div class="line">  </div><div class="line">    public static LazySingleton getInstance() </div><div class="line">	&#123;   </div><div class="line">        if (instance == null) //第一重判断 </div><div class="line">		&#123;  </div><div class="line">            //锁定代码块  </div><div class="line">            synchronized (LazySingleton.class) </div><div class="line">			&#123;  </div><div class="line">                if (instance == null) //第二重判断 </div><div class="line">				&#123;  </div><div class="line">                    instance = new LazySingleton(); //创建单例实例  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        return instance;   </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<pre><code>需要注意的是，如果使用双重检查锁定来实现懒汉式单例类，需要在静态成员变量instance之前增加修饰符volatile，被volatile修饰的成员变量可以确保多个线程都能够正确处理，且该代码只能在JDK 1.5及以上版本中才能正确执行。
由于volatile关键字会屏蔽Java虚拟机所做的一些代码优化，可能会导致系统运行效率降低，因此即使使用双重检查锁定来实现单例模式也不是一种完美的实现方式。 
</code></pre><ul>
<li>饿汉式单例类与懒汉式单例类比较</li>
</ul>
<ul>
<li>饿汉式单例类在类被加载时就将自己实例化，它的优点在于无须考虑多线程访问问题，可以确保实例的唯一性；从调用速度和反应时间角度来讲，由于单例对象一开始就得以创建，因此要优于懒汉式单例。但是无论系统在运行时是否需要使用该单例对象，由于在类加载时该对象就需要创建，因此从资源利用效率角度来讲，饿汉式单例不及懒汉式单例，而且在系统加载时由于需要创建饿汉式单例对象，加载时间可能会比较长。</li>
<li>懒汉式单例类在第一次使用时创建，无须一直占用系统资源，实现了延迟加载，但是必须处理好多个线程同时访问的问题，特别是当单例类作为资源控制器，在实例化时必然涉及资源初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的机率变得较大，需要通过双重检查锁定等机制进行控制，这将导致系统性能受到一定影响。</li>
<li>资源利用效率：饿汉式单例类 <code>优于</code> 懒汉式单例类</li>
<li>速度和反应时间：饿汉式单例类 <code>优于</code> 懒汉式单例类</li>
</ul>
<h3 id="八、重要实例"><a href="#八、重要实例" class="headerlink" title="八、重要实例"></a>八、重要实例</h3><ul>
<li><p>要求：<br>在现实生活中，居民身份证号码具有唯一性，同一个人不允许有多个身份证号码。<br>第一次申请身份证时将给居民分配一个身份证号码，<br>如果之后因为遗失等原因补办时，还是使用原来的身份证号码，不会产生新的号码。<br>现使用单例模式模拟该场景。 </p>
</li>
<li><p>模式结构分析图<br><img src="https://ooo.0o0.ooo/2017/06/22/594bdace5fed0.jpg" alt="模式结构分析图"></p>
</li>
<li><p>解决代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">class IdentityCardNo </div><div class="line">&#123;</div><div class="line">	// 被volatile修饰的成员变量可确保多个线程能够正确处理</div><div class="line">	private volatile static IdentityCardNo instance=null; //静态私有成员变量 </div><div class="line">	private String no;</div><div class="line">	</div><div class="line">	private IdentityCardNo()&#123;&#125; //私有构造函数 </div><div class="line">	</div><div class="line">	// 双重检查锁定（double check locking）</div><div class="line">	public static IdentityCardNo getInstance() //静态公有工厂方法，返回唯一实例 </div><div class="line">	&#123;</div><div class="line">		if(instance==null)// 第一重判断</div><div class="line">		&#123;</div><div class="line">			synchronized (IdentityCardNo.class)// 锁定代码块</div><div class="line">			&#123;</div><div class="line">				if(instance==null) // 第二重判断</div><div class="line">				&#123;</div><div class="line">					System.out.println(&quot;第一次办理身份证&quot;);</div><div class="line">					instance=new IdentityCardNo();</div><div class="line">					instance.setIdentityCardNo(&quot;44060321938312121&quot;);</div><div class="line">				&#125;</div><div class="line">				else</div><div class="line">					System.out.println(&quot;重复办理身份证，获取旧号码&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return instance;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void setIdentityCardNo(String no)&#123;</div><div class="line">		this.no=no;</div><div class="line">	&#125;</div><div class="line">	public String getIdentityCardNo()&#123;</div><div class="line">		return this.no;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">/*************************/</div><div class="line">class Client </div><div class="line">&#123;</div><div class="line">	public static void main(String args[])</div><div class="line">	&#123;</div><div class="line">		IdentityCardNo no1,no2;</div><div class="line">		no1=IdentityCardNo.getInstance();</div><div class="line">		no2=IdentityCardNo.getInstance();</div><div class="line">		System.out.println(&quot;身份证号码是否一致：&quot;+(no1==no2));</div><div class="line">		</div><div class="line">		String str1,str2;</div><div class="line">		str1=no1.getIdentityCardNo();</div><div class="line">		str2=no2.getIdentityCardNo();</div><div class="line">		System.out.println(&quot;内容是否相等：&quot;+str1.equalsIgnoreCase(str2));</div><div class="line">		System.out.println(&quot;是否是相同对象：&quot;+(str1==str2));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>从结果(都为true)可以看出，两次创建的 IdentityCardNo 对象内存地址相同，是同一个对象;<br>封装在其中的号码no属性不仅值相等，其内存地址也一致，是同一个成员属性。</p>
</li>
</ul>
<p>【参考】(作者：刘伟 <a href="http://blog.csdn.net/lovelion" target="_blank" rel="external">http://blog.csdn.net/lovelion</a>)</p>

  </section>

  
  
</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
